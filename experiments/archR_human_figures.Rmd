---
author: "Sarvesh Nikumbh"
date: '`r format(Sys.time(), "%d %B, %Y")`'
output: 
  bookdown::html_document2:
    toc: true
    toc_float: true
    number_sections: true
    anchor_sections: true
    number_tables: true
  editor_options:
    chunk_output_type: console
params:
  use_title: "archR result analysis report for CTSS in Human"
  sample_name: "human_cellGroup_merged"
  iqw_order_by_median: true
  data_path_on_disk: ""
  result_path_on_disk: ""
  result_dir_name: ""
  do_plot_arch: true
  do_iqw_tpm_plots: true
  do_bedfile_write: true
title: "`r params$use_title`"
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(collapse=TRUE)

data_path <- file.path("data")
results_path <- file.path("results")

## Setup paths on disk
data_path_on_disk <- data_path
result_path_on_disk <- results_path
##
archR_org_data_path <- file.path(data_path, "human")
use_minTPM <- 1
archR_org_results_path <- file.path(results_path, "human")


##
sample_name <- params$sample_name
result_dir_path <- file.path(params$result_path_on_disk, params$result_dir_name)
reordered <- params$reordered
dist_method <- params$dist_method
linkage <- params$linkage
topN_val <- params$topN_val
regularize_choice <- params$regularize
iteration <- params$archR_iteration
iqw_order_by_median <- params$iqw_order_by_median



#####
do_plot_seq_image <- params$do_plot_seq_image
do_plot_arch <- params$do_plot_arch
do_plot_strand_sep_arch <- params$do_plot_strand_sep_arch
do_motif_heatmaps <- params$do_motif_heatmaps
do_IQW_TPM_plots <- params$do_iqw_tpm_plots
do_bedfile_write <- params$do_bedfile_write
do_go_analysis <- params$do_go_analysis
do_per_clust_go_analysis <- params$do_per_clust_go_analysis
```

This CAGE data was obtained from ENCODE and processed by merging all cell lines 
data.

# Sample: `r sample_name` {#sample-name-section}

This file produces additional analyses plots for sample `r sample_name`, 
iteration `r iteration` of archR result.


## Parameter settings for this report

```{r param-settings}

params_df <- data.frame(param = names(params),
                        value = as.vector(unlist(params)))

knitr::kable(params_df)

```


```{r library, echo=FALSE, include=FALSE, message=FALSE}
seed_val <- 11992288
set.seed(seed_val)


library(CAGEr)
library(readr)
library(reshape2)
library(ggplot2)
library(ggeasy)
library(forcats)
library(patchwork)
library(cowplot)
## ^ for plotting
## 
## GenomeInfoDb now available in sarvesh's user library
library(GenomeInfoDb)
library(ChIPseeker)
library(clusterProfiler)
library(DT)
library(dplyr)

## for annotating CAGE data and GO term enrichment analysis in Mice
##
##
library(BSgenome.Hsapiens.UCSC.hg19)
# Use this to create one
library(GenomicFeatures)
TxDb.Hsapiens.UCSC.hg19.ensGene <- GenomicFeatures::makeTxDbFromUCSC(genome = "hg19", tablename = "ensGene")
# library(TxDb.Hsapiens.UCSC.hg19.knownGene) 
## ensGene is to be re-installed for R-4.0.0, but BiocManager says that it is not available for this version of R
library(org.Hs.eg.db)
library(dendextend)



```





## Plots for sections marked TRUE are included in this report.

```{r all_funcs, include=FALSE}

source('helper-funcs.R')

```


```{r setup-variables}

sample_names <- c("human_cellGroup_merged")#, "HepG2_cell_rep12")#, "hMSC-BM_cell_rep12")

archR_human_best_run <- vector("list", length(sample_names))
names(archR_human_best_run) <- sample_names

human_result <- vector("list", length(sample_names))
names(human_result) <- sample_names

human_bed_info <- vector("list", length(sample_names))
names(human_bed_info) <- sample_names

seqs_clusters_as_list <- vector("list", length(sample_names))
names(seqs_clusters_as_list) <- sample_names

seqs_clusters_as_list_ordered <- vector("list", length(sample_names))
names(seqs_clusters_as_list_ordered) <- sample_names

perSample_CAGEobj <- vector("list", length(sample_names))
names(perSample_CAGEobj) <- sample_names

perSample_peakAnno <- vector("list", length(sample_names))
names(perSample_peakAnno) <- sample_names

perSample_tissueSpec_pl <- vector("list", length(sample_names))
names(perSample_tissueSpec_pl) <- sample_names

samarth_df <- vector("list", length(sample_names))
names(samarth_df) <- sample_names
##


##
## lists storing plots
## 
## store iqw+tpm plots
perSample_pl <- vector("list", length(sample_names)) 
names(perSample_pl) <- sample_names

## store architectures' plots
perSample_arch <- vector("list", length(sample_names)) 
names(perSample_arch) <- sample_names

## store architectures' plots combined
perSample_arch_combined <- vector("list", length(sample_names)) 
names(perSample_arch_combined) <- sample_names


perSample_arch_posStrand <- vector("list", length(sample_names)) 
names(perSample_arch_posStrand) <- sample_names

perSample_arch_negStrand <- vector("list", length(sample_names)) 
names(perSample_arch_negStrand) <- sample_names

## store result_directory path
result_dir_path <- vector("list", length(sample_names)) 
names(result_dir_path) <- sample_names

## store go plots
perSample_go <- vector("list", length(sample_names)) 
names(perSample_go) <- sample_names


## store clusters
perSample_archR_clusts <- vector("list", length(sample_names))
names(perSample_archR_clusts) <- sample_names

## store overlaps info
perCluster_overlaps_perSample <- vector("list", length(sample_names)) 
names(perCluster_overlaps_perSample) <- sample_names


################################################################################
## Per section some variables need to be set. These are done here

# txdb <- TxDb.Dmelanogaster.UCSC.dm6.ensGene
## CAGEr object processing


# read TagClusters information from corresponding RDS file for sample
# All samples in one RDS object
cager_obj <- file.path(archR_org_data_path, 
                       paste0("samarth_hsapiens_TC_sample_human_cellGroup_merged_",
                       "minTPM", use_minTPM,
                       "_flank_up500_flank_down500_all70.rds"))
  
  # file.path("/mnt/storage/cage_datasets/",
  #                      "homo_sapiens/hg19/cager_objects",
  #           paste0("myCAGEset_Normalised_TagC_hsapiens_",
  #                  "hg19_ENCODE_processedMergedSamples.rds"))

ok_chr_names <- paste0("chr", c(1:21, "X", "Y"))

for(sn in sample_names){
    result_dir_path[[sn]] <- file.path(archR_org_results_path, 
                                       paste0(sn, "_results"))
}


```

```{r read-result-and-TCbed}



for(sn in sample_names){
    archR_human_best_run[[sn]] <- 
    file.path(archR_org_results_path, 
        paste0("archR_result_hsapiens_", sn,
               "_flank_up50_flank_down5_",
               "_modSelType_stability_chunkSize_5000", 
               "_bound_1e-06_collate_FTTTF"))
    if(file.exists(archR_human_best_run[[sn]])){
    human_result[[sn]] <- readRDS(file.path(archR_human_best_run[[sn]],
                                          "archRresult.rds"))
    }else{
    stop("Check if file exists. ", archR_human_best_run[[sn]])
    }
    ## Bed Info -- IQW and dominant TPM values 
    bed_fname <- file.path(archR_org_data_path, paste0("samarth_hsapiens_TC_sample_", sn, 
                                                   paste0("_minTPM", use_minTPM, "_all70"),
                                                   ".bed"))
    print(bed_fname)
    
    human_bed_info[[sn]] <- read.delim(file = bed_fname,
                          sep = "\t", header = TRUE)#,
                          # col.names = c("chr", "start", "end", "IQW", 
                          # "domTPM", "strand"))
    colnames(human_bed_info[[sn]]) <- c("chr", "start", "end", 
                                                    "IQW", "domTPM", "strand")
    ##
    message("Size of bed_info: ", nrow(human_bed_info[[sn]]))
}

```

For annotation, TSS region considered is -500 upstream and 100 nt downstream.

```{r make-cager-obj, echo=FALSE, collapse=TRUE}


# read TagClusters information from corresponding RDS file for sample
# All samples in one object

myCAGEobject <- readRDS(cager_obj)


## Per sample TCs
for(sn in sample_names){
      message("SAMPLE: ", sn)
      
      stopifnot(check_and_create_dir(result_dir_path[[sn]]))
      gr_CAGEobj_perSample_fname <- file.path(result_dir_path[[sn]], 
                                    paste("cagerObj", sn, "gr.rds", sep="_"))
      cage_sn <- paste0(sn)
      if(!file.exists(gr_CAGEobj_perSample_fname)){
          cli::cli_alert_info("Preparing new GRanges obj from CAGEr object")
      
      gr_myCAGEobject_thisSample <- GRanges(myCAGEobject)
  
  
      seqlengths(gr_myCAGEobject_thisSample) <- seqlengths(BSgenome.Hsapiens.UCSC.hg19)[names(seqlengths(gr_myCAGEobject_thisSample))]
      
      gr_myCAGEobject_thisSample <- trim(gr_myCAGEobject_thisSample)
      
      saveRDS(file = gr_CAGEobj_perSample_fname, 
                object = gr_myCAGEobject_thisSample)
    }else{
        cli::cli_alert_info("Using saved GRanges obj from CAGEr object")
        gr_myCAGEobject_thisSample <- readRDS(gr_CAGEobj_perSample_fname)
    }
    perSample_CAGEobj[[sn]] <- gr_myCAGEobject_thisSample
    perSample_peakAnno[[sn]] <- ChIPseeker::annotatePeak(gr_myCAGEobject_thisSample,
                                         tssRegion=c(-500, 100),
                                         TxDb=TxDb.Hsapiens.UCSC.hg19.ensGene,
                                         annoDb="org.Hs.eg.db")

}


```

## Order archR clusters by median IQ width {#prepare-objects}

By default, the clusters are ordered by their _median_ interquantile widths. 
One can choose to order by the _mean_ interquantile widths by setting paramater _iqw_order_by_median_ to `r FALSE`.


### ENCODE CAGE in Hsapiens cellGroup merged

```{r prepare-clusters-0}

## Sample 1, human_cellGroup_merged
sn <- 1
itr <- 5
use_aggl <- 'ward.D'
use_dist <- 'cor'

iter5_clusts_reord <- archR::collate_archR_result(
  result = human_result[[sn]],
  iter = itr, clust_method = 'hc', aggl_method = use_aggl,
  dist_method = use_dist, regularize = TRUE, topn = 50,
  flag = list(debugFlag = FALSE, verboseFlag = TRUE), collate = FALSE,
  return_order = TRUE)


## these are in default archR ordering
clust_archR_ord_list <- archR::get_seqs_clust_list(
  seqs_clust_lab = human_result[[ sn ]]$seqsClustLabels[[itr]])

## these are now ordered by the hc ordering
clust_hc_ord_list <- lapply(iter5_clusts_reord$order, function(x){
  clust_archR_ord_list[[x]]
})


ordered_arch_pl <- archR::plot_arch_for_clusters(
  seqs = human_result[[ sn ]]$rawSeqs,
  clust_list = clust_hc_ord_list, pos_lab = -50:150,
  xt_freq = 5, set_titles = FALSE, show = FALSE, bits_yax = "auto")

ordered_arch_pl2 <- lapply(rev(ordered_arch_pl), function(pl){
  pl <- pl +
        ggplot2::theme(axis.text = ggplot2::element_text(size = 0),
                       axis.text.x = ggplot2::element_text(
                         angle = 0, vjust = 2, hjust = 0.5),
                       axis.text.y = ggplot2::element_text(vjust = 0.5),
                       axis.title.y = ggplot2::element_text(size = 0),
                       axis.ticks.length = ggplot2::unit(0.00, "cm"),
                       plot.margin = ggplot2::unit(c(-0.1,0,-0.4,-0.4), "cm"))
})
sam_foo <- cowplot::plot_grid(plotlist = ordered_arch_pl2, ncol = 1)

use_cutk <- 8

stopifnot(check_and_create_dir(result_dir_path[[sn]]))
fname <- file.path(result_dir_path[[sn]], paste0(sample_names[sn], "_dend_arch_list_",
                                           use_dist, "_", use_aggl, "_",
                                           use_cutk, "clusters"))

sam_foo2 <- plot_dend_arch(arch_plot = sam_foo, fname = fname, use_cutk = use_cutk,
              clusts = iter5_clusts_reord, use_ht = 60, plot_png = FALSE,
              lwd = 0.4, repel = TRUE, show_labels = TRUE, labels_track_height = 0.25,
              rect = TRUE, rect_fill = TRUE,
              color_labels_by_k = TRUE)

## IMPORTANT: Seems like no additional manipulation is required. 


# 
# 
temp_clusts <- cutree(iter5_clusts_reord, k = use_cutk)
names(temp_clusts) <- NULL
## Make further few clusters
nCl <- length(unique(temp_clusts))

# TATA architectures
temp_clusts[c(34)] <- nCl + 1
temp_clusts[c(33)] <- nCl + 2
temp_clusts[c(35)] <- nCl + 3
temp_clusts[c(26)] <- nCl + 4

# TCT architecture
temp_clusts[c(37)] <- nCl + 5

temp_clusts[c(31)] <- nCl + 6
temp_clusts[c(36)] <- nCl + 6

temp_clusts[c(17)] <- temp_clusts[c(13)]

# Re-plot with proper coloring that shows the manipulations in clusters
use_cutk <- 8

stopifnot(check_and_create_dir(result_dir_path[[sn]]))
fname2 <- file.path(result_dir_path[[sn]], paste0(sample_names[sn], "_dend_arch_list_",
                                           use_dist, "_", use_aggl, "_",
                                           use_cutk, "clusters_final"))


## Also need to show alongside, how the final clusters' seqlogos look
clust_list <- lapply(unique(temp_clusts), function(x){which(temp_clusts == x)})
seqs_clusters_as_list[[sample_names[sn]]] <- archR::collate_clusters(clust_list, archR::get_seqs_clust_list(human_result[[sn]]$seqsClustLabels[[itr]]))
##

use_color <- scales::hue_pal()(length(unique(temp_clusts)))
sam_foo2 <- plot_dend_arch(arch_plot = sam_foo, fname = fname2, use_ht = 60,
               use_cutk = use_cutk,#length(unique(temp_clusts)), 
               clusts = iter5_clusts_reord, rect = TRUE, rect_fill = TRUE,
               label_cols = use_color[temp_clusts[iter5_clusts_reord$order]],
               k_colors = use_color, 
               clust_assignment = clust_list,
               new_clusts = seqs_clusters_as_list[[sample_names[sn]]],
               rawSeqs = human_result[[sample_names[sn]]]$rawSeqs,
               palette = FALSE, plot_png = FALSE)


cluster_medians_IQW <- unlist(lapply(seqs_clusters_as_list[[sn]], function(x){
    median(human_bed_info[[sn]]$IQW[x])
}))
cluster_means_IQW <- unlist(lapply(seqs_clusters_as_list[[sn]], function(x){
    mean(human_bed_info[[sn]]$IQW[x])
}))

if(iqw_order_by_median){
    ascending_order_IQW <- sort(cluster_medians_IQW, decreasing = FALSE,
                            index.return = TRUE)
}else{
    ascending_order_IQW <- sort(cluster_means_IQW, decreasing = FALSE,
                            index.return = TRUE)
}
##
seqs_clusters_as_list_ordered[[sn]] <-
                      lapply(ascending_order_IQW$ix,
                              function(x){
                                  seqs_clusters_as_list[[sn]][[x]]
                              })

perSample_archR_clusts[[sn]] <- seqs_clusters_as_list_ordered[[sn]]


```




```{r make-df-from-bed}

## Using Tau as a measure of tissue specificity
## This measure is defined/used in this paper:
##  https://www.aging-us.com/article/202648/text
## Various tissue specificity measures have been reviewed in this paper:
## https://doi.org/10.1093/bib/bbw008
## The above benchmarking paper finds Tau to be the most robust and sensitive 
## measure of tissue specificity. 
## 
tissueSpecTau <- read_csv(file.path(data_path, "tissueSpecificity-tau", 
                                    "Tau_score", "Tau_gene_V8.csv"), 
                          col_names = TRUE, show_col_types = FALSE)


tau_dist <- ggpubr::gghistogram(tissueSpecTau, x = "tau", 
    title = "Tau distribution/all genes (ensembl ids); N = 56156")
ggplot2::ggsave(file.path(result_dir_path[[sn]], "tau_distribution.pdf"), 
    plot = tau_dist, device = "pdf", width = 6, height = 4)

for(sn in sample_names) {
    clust_lens <- unlist(lapply(seqs_clusters_as_list_ordered[[sn]], length))
    message("Ordered list lengths: ", paste(clust_lens, collapse = " "))
    message("Original list lengths:", 
      paste(unlist(lapply(seqs_clusters_as_list[[sn]], length)), collapse = " "))
  
  
    ##
    clust_lab <- rep("0", length(human_result[[sn]]$rawSeqs))
    clust_names <- sort(as.character(1:length(seqs_clusters_as_list_ordered[[sn]])))
    for(i in seq_along(seqs_clusters_as_list_ordered[[sn]])){
        clust_lab[seqs_clusters_as_list_ordered[[sn]][[i]] ] <- clust_names[i]
    }
  
    peakAnno_df <- as.data.frame(perSample_peakAnno[[sn]])
    
    
    tissSpecScores <- vapply(seq(nrow(peakAnno_df)), FUN = function(x){
        idx <- which(tissueSpecTau$gene_id == peakAnno_df[x, "geneId"])
        if(length(idx) < 1){
            return(-1)
        }
        return(tissueSpecTau$tau[idx])
        }, FUN.VALUE=numeric(1))
    
    message("Tissue specificity values (tau) collected")
    
    
    ### Get DF ob BED information
    samarth_df[[sn]] <- data.frame(chr = human_bed_info[[sn]]$chr, 
                             start = human_bed_info[[sn]]$start,
                             end = human_bed_info[[sn]]$end,
                             # # See reason for commenting, above
                             # start = startLoc,
                             # end = endLoc,
                             strand = human_bed_info[[sn]]$strand,
                             IQW = human_bed_info[[sn]]$IQW,
                             domTPM = human_bed_info[[sn]]$domTPM,
                             # phast = use_phast,
                             geneId = peakAnno_df$geneId,
                             tissueSpecScore = tissSpecScores,
                             clust_ID = clust_lab #these are character sorted
                             )
    
    df_fname <- file.path(result_dir_path[[sn]], "samarth_info_df.csv")
    write.csv(samarth_df, file = df_fname)
    
    ## All, includes repeated ones
    fname <- file.path(result_dir_path[[sn]], "tau_existing_all_genes_distribution.pdf")
    p1 <- ggpubr::gghistogram(data.frame(tissSpecScores = tissSpecScores), 
                        x = "tissSpecScores",  y = "..count..")
    ggplot2::ggsave(filename = fname, plot = p1, device = pdf, width = 6, height = 4)
    
    ## Just for the 4th cluster which looks like TATA-box
    fname <- file.path(result_dir_path[[sn]], "tau_clust_4_distribution.pdf")
    p1 <- ggpubr::gghistogram(
        data.frame(tissSpecScores_clust4 = tissSpecScores[perSample_archR_clusts[[1]][[4]]]), 
        x = "tissSpecScores_clust4", y = "..count..")
    ggplot2::ggsave(filename = fname, plot = p1, device = pdf, width = 6, height = 4)
    
}

## Get iteration 5 clusters to further tease apart the TATA-cluster we 
## observe in iteration 4. This is cluster number 4 of 98 sequences that 
## is further bifurcated.

iter5_clusts <- archR::get_seqs_clust_list( human_result$human_cellGroup_merged$seqsClustLabels[[5]])

## Visually look for the relevant clusters in iter4 of the result object to 
## identify the relevant clusters at iter5
tata_clusts_idx <- lapply(c(1,3,4), function(x) seqs_clusters_as_list_ordered[[1]][[x]])

tissSpecScores_tata <- data.frame(tata_clust = c(rep(1, length(tata_clusts_idx[[1]])),
                                                rep(3, length(tata_clusts_idx[[2]])),
                                                rep(4, length(tata_clusts_idx[[3]]))), 
                                  clust_idx = c(tata_clusts_idx[[1]],
                                                tata_clusts_idx[[2]],
                                                tata_clusts_idx[[3]]),
           tissSpecScores = c(tissSpecScores[tata_clusts_idx[[1]]], 
                              tissSpecScores[tata_clusts_idx[[2]]],
                              tissSpecScores[tata_clusts_idx[[3]]]))

#

pl_tata <- ggpubr::ggboxplot(tissSpecScores_tata, 
                             x = "tata_clust", y = "tissSpecScores", 
                             #order = 2:1, 
                             outlier.shape = NA, 
                             notch = TRUE, ylim = c(0,1),
                             fill = RColorBrewer::brewer.pal(4, "Dark2")[4])
pl_tata <- ggpubr::ggpar(pl_tata, rotate = TRUE)
cowplot::ggsave2(file.path(result_dir_path[[sn]], "tau_distribution_for_tata_clusts_in_iqw_ordered_clusts.pdf"), plot = pl_tata, 
                 width = 6, height = 4)

```


## Cluster-wise BED files {#per-cluster-bedfiles}


```{r write-bed-files, results='asis', comment='', message=FALSE}

if(do_bedfile_write){
    message("Task: Write cluster-wise BED files to disk")
    for(sn in sample_names){
        stopifnot(check_and_create_dir(result_dir_path[[sn]]))
        ##
        bedFilesPath <- file.path(result_dir_path[[sn]], "Cluster_BED_tracks")
        stopifnot(check_and_create_dir(bedFilesPath))
        
        message("Writing cluster BED track files at:", bedFilesPath)
        ##
        #### Write bed to disk -- each cluster in a separate bed file
        cat(paste0("\n\n### Individual cluster track BED files [", sn, "]\n\n"))
        for(lo in seq_along(seqs_clusters_as_list_ordered[[sn]])){
            ##
            bedFilename <- file.path(bedFilesPath,
                                  paste0("hsapiens_TC_sample_", sn, 
                                  "_cluster", lo, ".bed"))
            # print(bedFilename)
            seq_ids <- seqs_clusters_as_list_ordered[[sn]][[lo]]
            limit_df <- samarth_df[[sn]][seq_ids,]
            track.name <- paste0(sn, "_hg19_", "clust", lo)
            write_as_track_bed(limit_df, seq_ids, track_name = track.name, 
                               bedFilename = bedFilename)
            dload_text <- xfun::embed_file(path = bedFilename,  
                        text = paste("Download coordinates for cluster", lo, " as browser track"))
            cat(paste0("\n<", dload_text$name," href=\"", dload_text$attribs$href, "\" download=\"", dload_text$attribs$download, "\">", dload_text$children[[1]][1],
                "</a>\n"))
        }
        #####
        message("Preparing strand-separated files")
        ## Strand-wise separate files per cluster
        cat(paste0("\n\n### Strand-separated individual cluster track BED files[", sn, "]\n\n"))
        for(lo in seq_along(seqs_clusters_as_list_ordered[[sn]])){
            ## plus strand
            bedFilename_plus <- file.path(bedFilesPath,
                                paste0("hsapiens_TC_sample_", sn, 
                                  "_cluster", lo, "_plus_strand.bed"))
            ##
            chosen_idx_plus_strand <- get_strand_specific_indices(df = samarth_df[[sn]],
                                seq_ids_in_clust = seqs_clusters_as_list_ordered[[sn]][[lo]],
                                strand_val = "+")
            ##
            if(length(chosen_idx_plus_strand) < 1){
              cat(paste0("<a href= >Empty",   "</a>"))
            }else{
            ##
              limit_df <- samarth_df[[sn]][chosen_idx_plus_strand,]
              track.name <- paste0(sn, "_hg19_", "clust", lo, "_plus_strand")
              write_as_track_bed(limit_df, chosen_idx_plus_strand, track_name = track.name, 
                                 bedFilename = bedFilename_plus)
              dload_text <- xfun::embed_file(bedFilename_plus, 
                          text = paste("Download coordinates for cluster", 
                                       lo, "(+ strand) as browser track"))
              cat(paste0("\n<", dload_text$name," href=\"", dload_text$attribs$href, "\" download=\"", dload_text$attribs$download, "\">", dload_text$children[[1]][1],
                  "</a>,  "))
            }
            ## minus strand
            bedFilename_minus <- file.path(bedFilesPath,
                                     paste0("hsapiens_TC_sample_",
                                            sn, "_cluster",
                                            lo, "_minus_strand.bed"))
            ##
            ##
            chosen_idx_minus_strand <- get_strand_specific_indices(df = samarth_df[[sn]],
                                seq_ids_in_clust = seqs_clusters_as_list_ordered[[sn]][[lo]],
                                strand_val = "-")
            ##
            if(length(chosen_idx_minus_strand) < 1){
              cat(paste0("<a href= >Empty",   "</a>\n"))
            }else{
              limit_df <- samarth_df[[sn]][chosen_idx_minus_strand,]
              track.name <- paste0(sn, "_hg19_", "clust", lo, "_plus_strand")
              write_as_track_bed(limit_df, chosen_idx_minus_strand, track_name = track.name, 
                                 bedFilename = bedFilename_minus)
              dload_text <- xfun::embed_file(bedFilename_minus, 
                    text = paste("Download coordinates for cluster", 
                                       lo, "(- strand) as browser track"))
              cat(paste0("<", dload_text$name," href=\"", dload_text$attribs$href, "\" download=\"", dload_text$attribs$download, "\">", dload_text$children[[1]][1], "</a>\n"))
            }
            ##
        }
    }
    ##
    dload_all <- xfun::embed_dir(bedFilesPath, 
              text = paste("Download all clusters as separate browser track files (zip)"))
        cat(paste0("\n### All cluster track files (one zipped folder of all BED files)\n\n"))
        cat(paste0("\n<", dload_all$name," href=\"", dload_all$attribs$href, "\" download=\"", dload_all$attribs$download, "\">", dload_all$children[[1]][1],
                "</a>\n"))
    ##
}else{
    message("do_bedfile_write is FALSE")
}

```



## IQW-TPM-PhastCons plots {#iqw-tpm-plots}



```{r iqw-tpm-plots, warning=FALSE, message=FALSE, eval=TRUE}

####
if(do_IQW_TPM_plots){
    message("Task: Producing IQW_TPM_PhastCons scores combined plot")
    for(sn in sample_names){
        stopifnot(check_and_create_dir(result_dir_path[[sn]]))
        pl_iqw <- get_iqw_ord_plot(iqw = TRUE, y_axis_text = TRUE, 
                    samarth_df = samarth_df[[sn]], 
                    seqs_clust = seqs_clusters_as_list_ordered[[sn]])
        pl_iqw <- pl_iqw + ggeasy::easy_all_text_size(size=18) + 
                  NULL +
                  ggeasy::easy_y_axis_labels_size(size=18) +
                  ggeasy::easy_x_axis_labels_size(size=18) +
                  NULL
        ##
        pl_tpm <- get_iqw_ord_plot(tpm = TRUE, y_axis_text = FALSE, 
                    samarth_df = samarth_df[[sn]], 
                    seqs_clust = seqs_clusters_as_list_ordered[[sn]])
        pl_tpm <- pl_tpm + ggeasy::easy_all_text_size(size=18) + 
                  NULL +
                  # ggeasy::easy_y_axis_labels_size(size=18) +
                  ggeasy::easy_x_axis_labels_size(size=14) +
                  NULL
        ##
        seqs_clust <- seqs_clusters_as_list_ordered[[sn]]
        clust_lens <- unlist(lapply(seqs_clust, length))
        clust_labels <- paste(1:length(seqs_clust),
                          paste0("(n=", clust_lens, ")"), sep="_")
        clr <- RColorBrewer::brewer.pal(4, "Dark2")
        pl_tspec <- ggplot2::ggplot(samarth_df[[sn]],
                     aes(y=fct_reorder(clust_ID, IQW,
                                       .fun = median,
                                       .desc = TRUE),
                         x=tissueSpecScore)) +
            ggplot2::geom_boxplot(outlier.size = 1, width = 0.5, notch = TRUE,
                         color = "black", fill = clr[4]) +
            # scale_x_log10() +
            xlab("Tissue Specificity (Tau)") +
            ylab("Clusters") +
            ggplot2::xlim(c(0,1)) +
            # scale_y_discrete(labels = rev(clust_labels)) +
            theme_bw() +
            theme(axis.title.y=element_blank(),
                  axis.text.y=element_blank(),
                  axis.ticks.y=element_blank()) +
            ggeasy::easy_all_text_size(size=18) + 
            ggeasy::easy_x_axis_labels_size(size=14)
        ##
        ## IQW ordered plots
        # iqw_tpm_ord_pls <- pl_iqw | pl_tpm
        iqw_tpm_phast_ord_pls <- pl_iqw | pl_tpm | pl_tspec
        perSample_pl[[sn]] <- iqw_tpm_phast_ord_pls
        
        title_str <- paste0("Sample_", sn, "_IQW_TPM_TissSpec_plot")
        # title_str <- paste0("Sample_", sn, "_IQW_TPM_plot")
        pl_w_title <- perSample_pl[[sn]] + plot_annotation(title = title_str)
        cowplot::save_plot(filename = file.path(result_dir_path[[sn]],
                paste0(title_str, ".pdf")),
                plot = pl_w_title,
                base_height = 12, base_width = 14
                )
        # cowplot::save_plot(filename = file.path(result_dir_path[[sn]],
        #         paste0(title_str, ".png")),
        #         plot = pl_w_title,
        #         base_height = 17, base_width = 14
        #         )
        
        # print(pl_w_title)
        
    }
    
}else{
    message("do_iqw_tpm_plot is FALSE")
}


```




## Sequence logos of cluster architectures {#arch-seqlogos}

Sequence logos of clusters ordered by their median interquantile width (ascending order). These are included as part of the combined panels.

```{r seqlogos, eval=TRUE}

#fig.width=11, fig.height=10, out.width="1200px", out.height="800px",

##
if(do_plot_arch){
    for(sn in sample_names){
        stopifnot(check_and_create_dir(result_dir_path[[sn]]))
        ##
        message("Generating architectures for clusters of sequences...")
        fname <- file.path(result_dir_path[[sn]],
                           paste0("Architectures_0-max.pdf"))
        iter5_human_arch_list <- lapply(seq_along(perSample_archR_clusts[[sn]]), 
          function(y){
          x <- perSample_archR_clusts[[sn]][[y]]
          pl <- archR::plot_ggseqlogo_of_seqs(as.character(human_result[[sn]]$rawSeqs[x]), 
            pos_lab = -50:150, bits_yax = "auto", title = NULL)
          pl <- pl + theme(axis.text = element_text(size=15), 
                     # axis.text.x = element_text(angle=0, vjust = 2, hjust = 0.5),
                     # axis.text.x = element_text(angle=90, vjust = 0, hjust = 0),
                     axis.text.y = element_text(vjust = 0.5),
                     axis.title.y = element_text(size=15),
                     axis.ticks.length = unit(0.04, "cm"),
                     plot.margin = unit(c(0,0.1,-0.4,0.1), "cm")) +
            ggplot2::scale_y_continuous(sec.axis = dup_axis(name = paste0("C",y), labels = NULL))
          # pl + theme(plot.margin = unit(c(0,0.2,-0.5,0.1), "cm"))
          # pl + theme(plot.margin = unit(c(0,0,-0.3,0), "cm"))
          
        })
        # print(length(iter5_dm_arch_list))
        
        r1c1 <- cowplot::plot_grid(plotlist = iter5_human_arch_list, ncol = 1)
        # cowplot::save_plot(fname, plot = r1c1, limitsize = FALSE, base_width = 30,
        #             nrow = length(seqs_clusters_as_list_ordered[[sn]]))
        cowplot::ggsave2(fname, plot= r1c1, width=25, height=60, units="cm",
              dpi = 600, limitsize = FALSE)
        
        ## save PNGs
        # for(p in 1:length(iter5_human_arch_list)){
        #     this_result_dir_path <- file.path(result_dir_path[[sn]], "arch_png")
        #     stopifnot(check_and_create_dir(this_result_dir_path))
        #     fname <- file.path(this_result_dir_path, 
        #             paste0("Architecture_clust", p, "_0-max.png"))
        #     cowplot::ggsave2(fname, plot= iter5_human_arch_list[[p]], 
        #       width=25, height=3, units="cm", dpi = 300)
        # }
        # r1c1
        perSample_arch_combined[[sn]] <- r1c1
        perSample_arch[[sn]] <- iter5_human_arch_list
        
        if(file.exists(fname)){
            knitr::include_graphics(fname)
        }
    }
}else{
    message("do_plot_arch is FALSE")
}
##



```


## Tissue-specificity plots 

The tissue specificity plots generated in this section can be viewed in sections
[Per cluster Architecture-GOTerms-TIssueSpecificity(GTEx)-Genes](#tripanel1) and [Per cluster Architecture-GOTerms-TIssueSpecificity(HPA)-Genes](#tripanel1-1). These tissue specific gene enrichment per cluster are computed using the TissueEnrich package from Bioconductor.

We now use the tissue specificity index 'tau' as a quantitative measure.
<!-- This is described in paper: https://www.aging-us.com/article/202648/text -->
Tau values for each human gene and transcript are available from: https://genomics.senescence.info/gene_expression/tau.html
These values are calculated using tissue-specific gene expression data from GTEx v8 as reported on the webpage above.
Genes with a tau index close 0 are equally expressed across all tissues and those closer to 1 are more specifically expressed in one tissue.
Various such quantitive tissue specificity measures are reviewed/benchmarked in the paper: https://academic.oup.com/bib/article/18/2/205/2562739
The benchmarking study reports Tau to be sensitive such that it identified all the tissue specific genes that were missed by other measures/indices.

For completeness sake, the tissue specific gene enrichment plots are retained in the per-cluster features in the carousels below. 
And the distribution of Tau values per cluster are plotted as part of the combined panel together with IQW, TPM etc.

```{r, trying-tau-score, eval=FALSE}

tissueSpecTau <- read_csv(file.path(data_path, "tissueSpecificity-tau", "Tau_score", "Tau_gene_V8.csv"), col_names = TRUE)

which_na <- which(is.na(peakAnno_df$ENTREZID))
naNonNa <- rep("non-NA", nrow(peakAnno_df))
naNonNa[which_na] <- "NA"
peakAnno_df <- as.data.frame(perSample_peakAnno[[1]])
ensembl_entrez_df <- data.frame(ensembl = peakAnno_df$geneId,
                                entrez = peakAnno_df$ENTREZID,
                                naNonNa =  naNonNa)


```



## Per sample list of Genes per cluster

```{r per-sample-entrezIDs-per-cluster}

perSample_geneList <- lapply(seq_along(perSample_archR_clusts), function(x){
            as_df_entrez_id <- as.data.frame(perSample_peakAnno[[x]])$ENTREZID
            sam <- lapply(perSample_archR_clusts[[x]], function(y){
              temp <- as_df_entrez_id[y]
              temp[which(!is.na(temp))]
            })
            names(sam) <- paste0("C", seq_along(sam))
            sam
        })
names(perSample_geneList) <- names(perSample_archR_clusts)

```


## Per cluster gene names


```{r per-clust-genes1, warning=FALSE, eval=TRUE}


sn <- sample_names[1]

peakAnno_df <- as.data.frame(perSample_peakAnno[[sn]])

unique_genes <- unique(peakAnno_df$SYMBOL)
sumTPM_across_TC_per_gene <- lapply(unique_genes, function(x){
    sum(peakAnno_df$tpm.dominant_ctss[which(peakAnno_df$SYMBOL == x)])
})
names(sumTPM_across_TC_per_gene) <- unique_genes


genes1 <- lapply(seq_along(perSample_archR_clusts[[sn]]), function(x){
      ##
      all_genenames <-
        peakAnno_df[unlist(perSample_archR_clusts[[sn]][x]), c("GENENAME", "ENTREZID", "geneId", "SYMBOL", "annotation", "width", "interquantile_width", "nr_ctss", "tpm.dominant_ctss")]
      ## To sort by motif scores, get motif scores first
      motif_scores <- suppressMessages(get_motif_scores(human_result, perSample_archR_clusts, sn, clust_id = x))
      ##
      anno_terms1 <- all_genenames$annotation
      anno_terms_splits <- strsplit(anno_terms1, " ")
      anno_terms <- unlist(lapply(anno_terms_splits, function(x){
            if(is.na(x[1])){ "NA";
            }else if(grepl("Intron", x[1]) || grepl("Exon", x[1])){
                paste0(x[1], " (", paste(x[3:6], collapse = " "))
            }else if(grepl("Promoter", x[1])){
                x[1]
            }else{ paste(x[1], x[2]) }
      }))
      ## To sort by motif match score
      sorted <- sort(motif_scores, index.return=TRUE,
                      decreasing = TRUE)
      
      ## To sort alphabetically by Gene Symbol
      naStr <- unlist(lapply(all_genenames$SYMBOL, function(x){
              if(is.na(x)){
                  "NA"
              }else{
                  x
              }
            }))
      all_genenames$SYMBOL <- naStr
      sorted <- sort(all_genenames$SYMBOL, index.return=TRUE)
      
      sam2 <- unlist(lapply(all_genenames$SYMBOL, function(x) {
          if(x != "NA"){
            sumTPM_across_TC_per_gene[[x]]
          }else{
            NA
          }
        }))
      
      # Displays as datatable which is sortable, searchable
      
      print_df <- data.frame("Symbol" = all_genenames$SYMBOL[sorted$ix],
                         "Weblink" = 
            paste0('<a href="https://www.ensembl.org/Homo_sapiens/Gene/Summary?db=core;g=',
            all_genenames$geneId[sorted$ix], '" target="_blank">',
            all_genenames$GENENAME[sorted$ix],
            '</a> '),
            "Annot" = anno_terms[sorted$ix],
            "domTPM" = format(round(all_genenames$tpm.dominant_ctss[sorted$ix], 3), nsmall=3),
            "%%.domTPM" = format(round(100*(all_genenames$tpm.dominant_ctss[sorted$ix]/sam2[sorted$ix]), 2), nsmall=2),
            "Match.score"= form_str(motif_scores[sorted$ix])
            )
      colnames(print_df)[5] <- "%domTPM"
      return(print_df)
      # Displays as general html text
      paste0('-- <span style="color:red">', all_genenames$SYMBOL[sorted$ix], '</span> ',
        '<a href="https://www.ensembl.org/Homo_sapiens/Gene/Summary?db=core;g=',
              all_genenames$geneId[sorted$ix], '" target="_blank">',
              all_genenames$GENENAME[sorted$ix],
        '</a> ',
        '<span style="color:black;font-size:15px">', anno_terms[sorted$ix], 
        # " (TCW: ", all_genenames$width[sorted$ix], "; ", 
        "; domTPM: ",
         all_genenames$tpm.dominant_ctss[sorted$ix] , ";", 
        " %domTPM: ", 
        all_genenames$tpm.dominant_ctss[sorted$ix]/sam2[sorted$ix], ";", 
        '</span> ',
        '<span style="color:green;font-size:12px">MatchScore: ', form_str(motif_scores[sorted$ix]), '</span> ',
       collapse=" <br/> ")
      ##
      
    })

genes <- lapply(genes1, function(x){
    DT::datatable(x, escape = c(1), rownames = FALSE, width = 600, height = 1200, 
                  options = list(paging= FALSE), 
                  caption = paste0("TSS info [", nrow(x), " entries] sorted by the gene symbol"))
})



```




## Sankey diagram 

### Sankey - inrKO 5_5 vs 2_2

```{r, sankey-diagram-KO, eval=FALSE}


inrKO_2_2_info_df <- read.csv(file.path(archR_org_results_path, 
                                "human_cellGroup_merged_inrKO_2_2_results", 
                                "samarth_info_df.csv"), header = TRUE)

inrKO_2_2_clust_lab <- as.character(inrKO_2_2_info_df$human_cellGroup_merged.clust_ID)

sorted_lab <- sort(unique(inrKO_2_2_clust_lab), index.return = TRUE) 

inrKO_2_2_clust_lab_int <- inrKO_2_2_clust_lab
nIdx <- 0
for(i in sorted_lab$x){
    nIdx <- nIdx + 1
    idx <- which(inrKO_2_2_clust_lab == i)
    inrKO_2_2_clust_lab_int[idx] <- length(sorted_lab$x) - nIdx + 1
}

#### For generating inrKO_2_2 seqlogos
inrKO_2_2_result <- readRDS(file.path(archR_org_results_path, 
        paste0("archR_result_hsapiens_", sn,
               "_flank_up50_flank_down150__inrKO_2_2",
               "_modSelType_stability_chunkSize_5000", 
               "_bound_1e-06_collate_FTTTF"), "archRresult.rds"))

use_clusts <- seqArchR::get_seqs_clust_list(seqs_clust_lab =
        as.character(inrKO_2_2_info_df$human_cellGroup_merged.clust_ID))

inrKO_2_2_seqlogos <- seqArchRplus::per_cluster_seqlogos(sname = sn, 
    seqs = as.character(inrKO_2_2_result$rawSeqs), 
    bits_yax = "max", one_plot = TRUE, txt_size = 20,
    clusts = use_clusts, dir_path = "."
)



##########


inrKO_5_5_info_df <- read.csv(file.path(archR_org_results_path, 
                                "human_cellGroup_merged_inrKO_5_5_results", 
                                "samarth_info_df.csv"), header = TRUE)

#### For generating inrKO_5_5 seqlogos
inrKO_5_5_result <- readRDS(file.path(archR_org_results_path, 
        paste0("archR_result_hsapiens_", sn,
               "_flank_up50_flank_down150__inrKO_5_5",
               "_modSelType_stability_chunkSize_5000", 
               "_bound_1e-06_collate_FTTTF"), "archRresult.rds"))

use_clusts <- seqArchR::get_seqs_clust_list(seqs_clust_lab =
        as.character(inrKO_5_5_info_df$human_cellGroup_merged.clust_ID))

inrKO_5_5_seqlogos <- seqArchRplus::per_cluster_seqlogos(sname = sn, 
    seqs = as.character(inrKO_5_5_result$rawSeqs), pos_lab = c(-50:-6,6:150),
    bits_yax = "max", one_plot = FALSE, txt_size = 20,
    clusts = use_clusts, dir_path = NULL
)

inrKO_5_5_seqlogos <- lapply(seq_along(inrKO_5_5_seqlogos), function(x){
    foo <- inrKO_5_5_seqlogos[[x]]+ ggplot2::theme(title = element_blank())
    if(x %% 5 != 0){
        foo2 <- foo + ggplot2::theme(
                    axis.text.x.bottom = element_blank(),
                    axis.ticks.length.y.left = ggplot2::unit(0.05, "cm"),
                    axis.ticks.length.x.bottom = ggplot2::unit(0.1, "cm"),
                    plot.margin = ggplot2::unit(c(0.2, 0.3, 0.1, 0.1), "cm"))
        return(foo2)
    }else{
        foo2 <- foo + ggplot2::theme(
                    plot.margin = ggplot2::unit(c(0.2, 0.3, 0.1, 0.1), "cm"))
        return(foo2)
    }
})

inrKO_5_5_seqlogos <- cowplot::plot_grid(plotlist = inrKO_5_5_seqlogos, ncol = 1)


#####

inrKO_5_5_clust_lab <- as.character(inrKO_5_5_info_df$human_cellGroup_merged.clust_ID)

sorted_lab <- sort(unique(inrKO_5_5_clust_lab), index.return = TRUE) 

inrKO_5_5_clust_lab_int <- inrKO_5_5_clust_lab
nIdx <- 0
use_labs <- paste0("C", seq(length(sorted_lab$x)))
for(i in sorted_lab$x){
    nIdx <- nIdx + 1
    idx <- which(inrKO_5_5_clust_lab == i)
    inrKO_5_5_clust_lab_int[idx] <- length(sorted_lab$x) - nIdx + 1
}

##########



inrKO_clust_lab_df <- data.frame(inrKO_5_5 = inrKO_5_5_clust_lab_int,
                                inrKO_2_2 = inrKO_2_2_clust_lab_int)


library(ggplot2)
library(ggsankey)
library(dplyr)

long_df <- ggsankey::make_long(inrKO_clust_lab_df, 
                            inrKO_5_5, inrKO_2_2)
long_df$cname <- paste0("C", ifelse(is.na(long_df$next_node), 

        1+length(unique(inrKO_2_2_clust_lab))-
                        as.integer(long_df$node),
        1+length(unique(inrKO_5_5_clust_lab))
                        -as.integer(long_df$node)))



sankey_pl <- ggplot2::ggplot(long_df, aes(x = x, 
     next_x = next_x, 
     node = as.integer(node),
     next_node = as.integer(next_node),
     fill = factor(as.integer(node))
     , label = cname 
     )) +
     ggsankey::geom_sankey() +
     ggsankey::geom_sankey_label(size = 8, color = "white", fill = "gray20") +
     ggplot2::coord_cartesian(expand = FALSE) +
     ggplot2::theme_minimal() +
     theme(legend.position = "none", axis.title.x = element_text(size= 0),
         axis.text.x.bottom = element_text(size = 0),
         axis.text.y.left = element_text(size = 0),
         axis.ticks = element_line(size = 0),
         plot.margin = ggplot2::margin(0,0,0,0, "cm"))

fname <- file.path("inrKO_5_vs_2_sankey_plot.pdf")
ggsave(fname, plot = sankey_pl, device = "pdf", width = 20, height = 20)

all_one_col_pl <- cowplot::plot_grid(inrKO_5_5_seqlogos, 
                                    sankey_pl,
                                    inrKO_2_2_seqlogos,
                                    rel_widths = c(1,0.75,1),
                                    ncol = 3, nrow = 1)
cowplot::save_plot("inrKO_5_5_vs_2_2_combined.pdf", 
    plot = all_one_col_pl, limitsize = FALSE, 
    base_width = 50, base_height = 25, nrow = 1)


```

### Sankey - nonKO Short vs long flank


```{r, sankey-diagram-non-KO, eval=FALSE}

short50_5_info_df <- read.csv(file.path(result_dir_path[[1]], "samarth_info_df.csv"), header = TRUE)

short50_5_clust_lab <- as.character(short50_5_info_df$human_cellGroup_merged.clust_ID)

sorted_lab <- sort(unique(short50_5_clust_lab), index.return = TRUE) 

short50_5_clust_lab_int <- short50_5_clust_lab
nIdx <- 0
for(i in sorted_lab$x){
    nIdx <- nIdx + 1
    idx <- which(short50_5_clust_lab == i)
    short50_5_clust_lab_int[idx] <- length(sorted_lab$x) - nIdx + 1
}


#### For generating short flank seqlogos
short50_5_result <- readRDS(file.path(archR_org_results_path, 
        paste0("archR_result_hsapiens_", sn,
               "_flank_up50_flank_down5_",
               "_modSelType_stability_chunkSize_5000", 
               "_bound_1e-06_collate_FTTTF"), "archRresult.rds"))

use_clusts <- seqArchR::get_seqs_clust_list(seqs_clust_lab =
        as.character(short50_5_info_df$human_cellGroup_merged.clust_ID))

short50_5_seqlogos <- seqArchRplus::per_cluster_seqlogos(sname = sn, 
    seqs = as.character(short50_5_result$rawSeqs), pos_lab = -50:5,
    bits_yax = "max", one_plot = TRUE, txt_size = 20,
    clusts = use_clusts, dir_path = "."
)


#########

long50_150_info_df <- read.csv(file.path(archR_org_results_path, 
    "human_cellGroup_merged150_downstream_results", 
    "samarth_info_df.csv"), header = TRUE)

long50_150_clust_lab <- as.character(long50_150_info_df$human_cellGroup_merged.clust_ID)

sorted_lab <- sort(unique(long50_150_clust_lab), index.return = TRUE) 

long50_150_clust_lab_int <- long50_150_clust_lab
nIdx <- 0
for(i in sorted_lab$x){
    nIdx <- nIdx + 1
    idx <- which(long50_150_clust_lab == i)
    long50_150_clust_lab_int[idx] <- length(sorted_lab$x) - nIdx + 1
}


#### For generating longflank seqlogos
long50_150_result <- readRDS(file.path(archR_org_results_path, 
        paste0("archR_result_hsapiens_", sn,
               "_flank_up50_flank_down150_",
               "_modSelType_stability_chunkSize_5000", 
               "_bound_1e-06_collate_FTTTF"), "archRresult.rds"))

use_clusts <- seqArchR::get_seqs_clust_list(seqs_clust_lab =
        as.character(long50_150_info_df$human_cellGroup_merged.clust_ID))

long50_150_seqlogos <- seqArchRplus::per_cluster_seqlogos(sname = sn, 
    seqs = as.character(long50_150_result$rawSeqs), pos_lab = -50:150,
    bits_yax = "max", one_plot = FALSE, txt_size = 20,
    clusts = use_clusts, dir_path = NULL
)

long50_150_seqlogos <- lapply(seq_along(long50_150_seqlogos), function(x){
    foo <- long50_150_seqlogos[[x]]+ ggplot2::theme(title = element_blank())
    if(x %% 5 != 0){
        foo2 <- foo + ggplot2::theme(
                    axis.text.x.bottom = element_blank(),
                    axis.ticks.length.y.left = ggplot2::unit(0.05, "cm"),
                    axis.ticks.length.x.bottom = ggplot2::unit(0.1, "cm"),
                    plot.margin = ggplot2::unit(c(0.2, 0.3, 0.1, 0.1), "cm"))
        return(foo2)
    }else{
        foo2 <- foo + ggplot2::theme(
                    plot.margin = ggplot2::unit(c(0.2, 0.3, 0.1, 0.1), "cm"))
        return(foo2)
    }
})

long50_150_seqlogos <- cowplot::plot_grid(plotlist = long50_150_seqlogos, ncol = 1)

##########

nonKO_clust_lab_df <- data.frame(shortFlanks_50_5 = short50_5_clust_lab_int,
                                longFlank_50_150 = long50_150_clust_lab_int)

library(ggsankey)

long_df <- ggsankey::make_long(nonKO_clust_lab_df, 
                            shortFlanks_50_5, longFlank_50_150)
long_df$cname <- paste0("C", ifelse(is.na(long_df$next_node), 
        1+length(unique(long50_150_clust_lab))
                        -as.integer(long_df$node), 
        1+length(unique(short50_5_clust_lab))-
                        as.integer(long_df$node)))


sankey_pl <- ggplot(long_df, aes(x = x, 
     next_x = next_x, 
     node = as.integer(node), 
     next_node = as.integer(next_node),
     fill = factor(as.integer(node)),
     label = cname
     )) +
     ggsankey::geom_sankey() +
     ggsankey::geom_sankey_label(size = 8, color = "white", fill = "gray20") +
     ggplot2::coord_cartesian(expand = FALSE) +
     ggplot2::theme_minimal() +
     theme(legend.position = "none", axis.title.x = element_text(size= 0),
         axis.text.x.bottom = element_text(size = 0),
         axis.text.y.left = element_text(size = 0),
         axis.ticks = element_line(size = 0),
         plot.margin = ggplot2::margin(0,0,0,0, "cm"))

fname <- file.path("nonKO_short_long_sankey_plot.pdf")
ggsave(fname, plot = sankey_pl, device = "pdf", width = 20, height = 20)

all_one_col_pl <- cowplot::plot_grid(short50_5_seqlogos, 
                                    sankey_pl,
                                    long50_150_seqlogos,
                                    rel_widths = c(0.7,0.5,1),
                                    ncol = 3, nrow = 1)
cowplot::save_plot("nonKO_short_long_combined.pdf", 
    plot = all_one_col_pl, limitsize = FALSE, 
    base_width = 50, base_height = 35, nrow = 1)



```

### Sankey - nonKO vs KO (long) flank


```{r, sankey-diagram-nonKO-vs-KO, eval=FALSE}


#########

long50_150_info_df <- read.csv(file.path(archR_org_results_path, 
    "human_cellGroup_merged150_downstream_results", 
    "samarth_info_df.csv"), header = TRUE)

long50_150_clust_lab <- as.character(long50_150_info_df$human_cellGroup_merged.clust_ID)

sorted_lab <- sort(unique(long50_150_clust_lab), index.return = TRUE) 

long50_150_clust_lab_int <- long50_150_clust_lab
nIdx <- 0
for(i in sorted_lab$x){
    nIdx <- nIdx + 1
    idx <- which(long50_150_clust_lab == i)
    long50_150_clust_lab_int[idx] <- length(sorted_lab$x) - nIdx + 1
}


#### For generating longflank seqlogos
long50_150_result <- readRDS(file.path(archR_org_results_path, 
        paste0("archR_result_hsapiens_", sn,
               "_flank_up50_flank_down150_",
               "_modSelType_stability_chunkSize_5000", 
               "_bound_1e-06_collate_FTTTF"), "archRresult.rds"))

use_clusts <- seqArchR::get_seqs_clust_list(seqs_clust_lab =
        as.character(long50_150_info_df$human_cellGroup_merged.clust_ID))

long50_150_seqlogos <- seqArchRplus::per_cluster_seqlogos(sname = sn, 
    seqs = as.character(long50_150_result$rawSeqs), pos_lab = -50:150,
    bits_yax = "max", one_plot = FALSE, txt_size = 20,
    clusts = use_clusts, dir_path = NULL
)

long50_150_seqlogos <- lapply(seq_along(long50_150_seqlogos), function(x){
    foo <- long50_150_seqlogos[[x]]+ ggplot2::theme(title = element_blank())
    if(x %% 5 != 0){
        foo2 <- foo + ggplot2::theme(
                    axis.text.x.bottom = element_blank(),
                    axis.ticks.length.y.left = ggplot2::unit(0.05, "cm"),
                    axis.ticks.length.x.bottom = ggplot2::unit(0.1, "cm"),
                    plot.margin = ggplot2::unit(c(0.2, 0.3, 0.1, 0.1), "cm"))
        return(foo2)
    }else{
        foo2 <- foo + ggplot2::theme(
                    plot.margin = ggplot2::unit(c(0.2, 0.3, 0.1, 0.1), "cm"))
        return(foo2)
    }
})

long50_150_seqlogos <- cowplot::plot_grid(plotlist = long50_150_seqlogos, ncol = 1)

##########

nonKO_vs_KO_clust_lab_df <- data.frame(
                                longFlank_50_150 = long50_150_clust_lab_int,
                                inrKO_5_5 = inrKO_5_5_clust_lab_int)

library(ggsankey)

long_df <- ggsankey::make_long(nonKO_vs_KO_clust_lab_df, 
                            longFlank_50_150, inrKO_5_5)
long_df$cname <- paste0("C", ifelse(is.na(long_df$next_node), 
        1+length(unique(inrKO_5_5_clust_lab))-
                        as.integer(long_df$node), 
        1+length(unique(long50_150_clust_lab))
                        -as.integer(long_df$node)))


sankey_pl <- ggplot(long_df, aes(x = x, 
     next_x = next_x, 
     node = as.integer(node), 
     next_node = as.integer(next_node),
     fill = factor(as.integer(node)),
     label = cname
     )) +
     ggsankey::geom_sankey() +
     ggsankey::geom_sankey_label(size = 8, color = "white", fill = "gray20") +
     ggplot2::coord_cartesian(expand = FALSE) +
     ggplot2::theme_minimal() +
     theme(legend.position = "none", axis.title.x = element_text(size= 0),
         axis.text.x.bottom = element_text(size = 0),
         axis.text.y.left = element_text(size = 0),
         axis.ticks = element_line(size = 0),
         plot.margin = ggplot2::margin(0,0,0,0, "cm"))

fname <- file.path("nonKO_vs_KO_long_sankey_plot.pdf")
ggsave(fname, plot = sankey_pl, device = "pdf", width = 20, height = 20)

all_one_col_pl <- cowplot::plot_grid(long50_150_seqlogos, 
                                    sankey_pl,
                                    inrKO_5_5_seqlogos,
                                    rel_widths = c(1,0.5,1),
                                    ncol = 3, nrow = 1)
cowplot::save_plot("nonKO_vs_KO_long_combined.pdf", 
    plot = all_one_col_pl, limitsize = FALSE, 
    base_width = 50, base_height = 30, nrow = 1)



```


<!-- ## Cross-scoring different architectures -->

```{r, cross-score-arch, include=FALSE, eval=FALSE}
library(motifStack)

sn <- sample_names[1]

sam_pfms <- lapply(perSample_archR_clusts[[sn]], function(x){
    seqs <- 
      human_result[[sn]]$rawSeqs[x]
    sam_pfm <- Biostrings::consensusMatrix(seqs)[1:4,]
    TFBSTools::PFMatrix(profileMatrix = sam_pfm)
    # TFBSTools::toPWM(sam_pfm)
})

sim_mat_list <- lapply(sam_pfms, function(x){
    xy_sim <- unlist(lapply(sam_pfms, function(y){
      # TFBSTools::PWMSimilarity(y, x, method = "Pearson")
      xy <- TFBSTools::PFMSimilarity(y, x)  
      as.numeric(xy["relScore"])
    }))
    
})

sim_mat <- do.call(cbind, sim_mat_list)



sim_mat_hclust <- hclust(dist(sim_mat))

plot(as.dendrogram(sim_mat_hclust))

# for(cl in perSample_archR_clusts[[sn]]){
#   seqs <- 
#     human_result[[sn]]$rawSeqs[perSample_archR_clusts[[sn]][cl][[1]]]
#   sam_pfm <- Biostrings::consensusMatrix(seqs)[1:4,]
# }

library(RColorBrewer)

# Classic palette BuPu, with 4 colors
coul <- brewer.pal(8, name = "PuBuGn") 

# Add more colors to this palette :
coul <- colorRampPalette(coul)(256)
# pie(rep(1, length(coul)), col = coul , main="") 

heatmap3::heatmap3(sim_mat, scale = "none", Rowv = NA, Colv = NA, col = coul, balanceColor = FALSE, revC = TRUE)

```


## Figures for the paper

### For paper: Proportion of ribosomal protein genes in various clusters

Check the proportion of ribosomal genes in the different seqArchR clusters from human CAGE data.

```{r ribo-prop}
## 


use_txt_size <- c(14)
names(use_txt_size) <- sample_names

use_cols <- wesanderson::wes_palette("Royal1", 2)
for(sn in sample_names){
    go_df <- as.data.frame(perSample_peakAnno[[sn]])
    
    
    new_df <- data.frame(cluster = as.character(samarth_df[[sn]]$clust_ID),
                         # character sorted clust names/ID, meaning 1 is
                         # followed by 10, 11, 12,13,14 then 2, 3, ...
                         # and so on
                         genename = go_df$GENENAME,
                         symbol = go_df$SYMBOL,
                         isNotRibosomal = rep(TRUE, length(nrow(go_df))),
                         isRibosomal = rep(FALSE, length(nrow(go_df))),
                         isRiboPseudogene = rep(FALSE, length(nrow(go_df))),
                         isRiboMitochondrial = rep(FALSE, length(nrow(go_df)))
                        )
    idx <- grep("ribosomal", go_df$GENENAME, ignore.case = TRUE)
    new_df$isRibosomal[idx] <- TRUE
    new_df$isNotRibosomal[idx] <- FALSE
    idx2 <- grep("pseudogene", go_df$GENENAME[idx], ignore.case = TRUE)
    new_df$isRiboPseudogene[idx[idx2]] <- TRUE
    idx2 <- grep("mitochondrial", go_df$GENENAME[idx], ignore.case = TRUE)
    new_df$isRiboMitochondrial[idx[idx2]] <- TRUE
    
    # perClusterRiboProp <- lapply(seqs_clusters_as_list_ordered[[sn]], function(x){
    #     this_df <- new_df[x, seq(ncol(new_df))]
    #     riboNotRibo <- as.vector(table(this_df$isNotRibosomal))
    #     # names(riboNotRibo) <- c("Ribosomal", "Non-ribosomal")
    #     # riboNotRibo
    #     # riboPseudo <- as.vector(table(this_df$isRiboPseudogene))[2]
    #     riboMito <- as.vector(table(this_df$isRiboMitochondrial))[2]
    #     dummy <- c(riboNotRibo, riboMito)
    #     # any NAs mean there were zero satisfying condition, set them to 0
    #     dummy[which(is.na(dummy))] <- 0
    #     names(dummy) <- c("Ribosomal", "Non-ribosomal", "Mitochondrial Ribosomal")
    #     dummy
    # })
    # names(perClusterRiboProp) <- paste0("C", seq(length(perClusterRiboProp)))
    
    # Only incorporating ribo and non-ribo
    perClusterRiboProp <- lapply(seqs_clusters_as_list_ordered[[sn]], function(x){
        this_df <- new_df[x, seq(ncol(new_df))]
        riboNotRibo <- as.vector(table(this_df$isNotRibosomal))
        names(riboNotRibo) <- c("Ribosomal", "Other")
        riboNotRibo
    })
    names(perClusterRiboProp) <- paste0("C", seq(length(perClusterRiboProp)))
    
}

sam <- dplyr::bind_rows(perClusterRiboProp)
sam$clusterNames <- names(perClusterRiboProp)
sam$clusterIndex <- seq_along(perClusterRiboProp)

melted_df <- reshape2::melt(sam,
                id.vars = c('clusterNames', "clusterIndex")#,
                # measure.vars = paste0("Iteration", 2:1)
                # measure.vars = c("")
                )

# ribo_pl <- ggplot(new_df, )

ribo_pl <- ggplot(melted_df, aes(fill = variable,
                                 y = fct_rev(reorder(clusterNames, clusterIndex)),
                                 x = value
                                 )) +
            ggplot2::geom_bar(position="fill", stat="identity") +
        ggplot2::scale_fill_manual(values = wesanderson::wes_palette("Royal2", 5)[c(5,4)]) + 
    ggplot2::theme_classic() +
    ggplot2::theme(axis.title.y.left = element_text(color = "black", size = use_txt_size[sn]),
                   axis.text = element_text(color = "black", size = use_txt_size[sn]),
                   axis.title.x.bottom = element_text(size= use_txt_size[sn]),
                   legend.position = "bottom", 
                   # axis.line.y.left = element_blank(),
                   # axis.line.y.right = element_line(),
                   legend.title = element_text(size = use_txt_size[sn], 
                                               color = "black"),
                   legend.text = element_text(size = use_txt_size[sn])
                   ) + 
    # ggplot2::scale_y_discrete(sec.axis = dup_axis(labels = sam$clusterNames)) + 
    ggplot2::xlab("Proportion") + 
    ggplot2::ylab("Clusters") +
    ggplot2::guides(fill = guide_legend(title = "Gene type", nrow = 2))

                            
dual_ini_prom <- read.csv(file.path(data_path_on_disk, "dual-initiation-promoters", "dual-initiation-promoters-human-drosophila.csv"), 
                          header = FALSE, skip = 4, sep = ",", 
                          col.names = c("human.gene.name", 
                                        "human.initiation.type",
                                        "human.YRorYCdominant", 
                                        "NA", 
                                        "drosophila.gene.name", 
                                        "drosophila.initiation.type",
                                        "drosophila.YRorYCdominant")
                          )
                          
dual_ini_prom_human <- dual_ini_prom[,c(1:3)]


perCluster_match_len <- lapply(seqs_clusters_as_list_ordered[[1]], function(x){
    match_genes_clust <- intersect(dual_ini_prom_human$human.gene.name,
                                go_df[x, "SYMBOL"])
    match_genes_clust_idx <- rep(FALSE, length(x))
    for(i in match_genes_clust){
        idx <- which(go_df[x, "SYMBOL"] == i)
        match_genes_clust_idx[idx] <- TRUE
    }
    
    match_len <- as.vector(table(match_genes_clust_idx))
    names(match_len) <- c("Other", "Dual Initiation")
    match_len <- match_len
    match_len
    # match_genes_clust_idx <- rep(FALSE, length(seqs_clusters_as_list_ordered[[1]][[x]]))
    # for(i in match_genes_clust){
    #     idx <- which(go_df[seqs_clusters_as_list_ordered[[1]][[x]], "SYMBOL"] == i)
    #     match_genes_clust_idx[idx] <- TRUE
    # }
    # match_genes_clust_idx <- which(match_genes_clust_idx)
})
names(perCluster_match_len) <- paste0("C", seq(length(perCluster_match_len)))


sam <- dplyr::bind_rows(perCluster_match_len)
sam$clusterNames <- names(perCluster_match_len)
sam$clusterIndex <- seq_along(perCluster_match_len)

melted_df <- reshape2::melt(sam,
                id.vars = c('clusterNames', "clusterIndex")#,
                # measure.vars = paste0("Iteration", 2:1)
                # measure.vars = c("")
                )

# ribo_pl <- ggplot(new_df, )

dualini_pl <- ggplot(melted_df, aes(fill = variable,
                                 y = fct_rev(reorder(clusterNames, clusterIndex)),
                                 x = value
                                 )) +
            ggplot2::geom_bar(position="fill", stat="identity") + 
            ggplot2::scale_fill_manual(values = wesanderson::wes_palette("Zissou1", 4)[c(2,4)]) + 
    ggplot2::theme_classic() +
    ggplot2::theme(axis.title.y.left = element_blank(),
                   axis.text.y.left = element_blank(),
                   axis.text = element_text(color = "black", size = use_txt_size[sn]),
                   axis.title.x.bottom = element_text(size= use_txt_size[sn]),
                   legend.position = "bottom", legend.title = element_text(size = use_txt_size[sn]),
                   legend.text = element_text(size = use_txt_size[sn]) 
                   ) +
    ggplot2::xlab("Proportion") + 
    ggplot2::guides(fill = guide_legend(title = "Promoter type", nrow = 2))


comb_pl1 <- cowplot::plot_grid(ribo_pl, dualini_pl, ncol = 2, align = "h")

cowplot::save_plot(comb_pl1, filename = file.path(result_dir_path[[sn]], 
                paste0("ribo_dual_combined_plot.pdf")), ncol = 2, base_height = 10, base_width = 5,
                dpi = 300)

## sequence logo excluding dual initiation promoters
# pl1 <- archR::plot_ggseqlogo_of_seqs(
#     human_result$human_cellGroup_merged$rawSeqs[seqs_clusters_as_list_ordered[[1]][[6]]], 
#     bits_yax = "auto", xt_freq = 15, pos_lab = c(-55,5))
# 
# pl2 <- archR::plot_ggseqlogo_of_seqs(
#     human_result$human_cellGroup_merged$rawSeqs[seqs_clusters_as_list_ordered[[1]][[6]]][-match_genes_clust_idx], 
#     bits_yax = "auto", xt_freq = 15, pos_lab = c(-55,5))
# 
# pl3 <- archR::plot_ggseqlogo_of_seqs(
#     human_result$human_cellGroup_merged$rawSeqs[seqs_clusters_as_list_ordered[[1]][[6]]][match_genes_clust_idx], 
#     bits_yax = "auto", xt_freq = 15, pos_lab = c(-55,5))
# 
# 
# pl <- cowplot::plot_grid(pl1, pl2, pl3, align = "v", nrow= 3, ncol = 1, base_width = 10)

```

### For paper: Proportion of housekeeping genes in different clusters

We fetched the list of house keeping genes from (this)[https://doi.org/10.1016/j.tig.2013.05.010] article. We make the check against this list which is stored on disk under data/human.

```{r hk-genes-match}

hk_genes_list_file <- file.path(archR_org_data_path, "HK_genes.txt")
hk_genes_list <- read.delim(hk_genes_list_file, header = FALSE)
colnames(hk_genes_list) <- c("SYMBOL", "RefSeq_Transcript")
hk_genes_list$SYMBOL <- trimws(hk_genes_list$SYMBOL)

# get per cluster number of housekeeping genes


use_cols <- wesanderson::wes_palette("Royal1", 2)
for(sn in sample_names){
    intersections <- data.frame(cluster = paste0("C", seq_along(seqs_clusters_as_list_ordered[[sn]])),
                                nOfHKgenes = rep(0, length(seqs_clusters_as_list_ordered[[sn]])),
                                totalSeqs = unlist(lapply(seqs_clusters_as_list_ordered[[sn]], length)),
                                percentage = rep(0, length(seqs_clusters_as_list_ordered[[sn]])))
    go_df <- as.data.frame(perSample_peakAnno[[sn]])
    for(y in 1:length(seqs_clusters_as_list_ordered[[sn]])){
        this_cl <- seqs_clusters_as_list_ordered[[sn]][[y]]
        intersections$nOfHKgenes[y] <- length(intersect(go_df$SYMBOL[this_cl], hk_genes_list$SYMBOL))
    }
    intersections$percentage = 100 * (intersections$nOfHKgenes / intersections$totalSeqs)
}

abs_pl <- ggpubr::ggbarplot(intersections, x = "cluster", y = "nOfHKgenes", width = 0.5,
                            fill =  use_cols[1], ylab = "# HK genes", 
                            order = intersections$cluster[sort(intersections$percentage, decreasing = FALSE, 
                                         index.return = TRUE)$ix])
abs_pl <- abs_pl + ggplot2::theme(axis.text.x.bottom = element_blank(), 
                                  axis.title.x.bottom = element_blank(),
                                  axis.title.y.left = element_text(color = "black",
                                                                   size = use_txt_size[sn]),
                                  axis.text = element_text(size = use_txt_size[sn])
                   )


percentage_pl <- ggpubr::ggbarplot(intersections, x = "cluster", y = "percentage", width = 0.5,
                                   fill = use_cols[2], ylab = "% HK genes", xlab = "Clusters", 
                                   order = intersections$cluster[sort(intersections$percentage, 
                                                               decreasing = FALSE, 
                                                               index.return = TRUE)$ix])
percentage_pl <- percentage_pl + ggplot2::theme(
                                    axis.text.x.bottom = element_text(color = "black",
                                                                    size = use_txt_size[sn]-2), 
                                  axis.title = element_text(color= "black", 
                                                            size = use_txt_size[sn]),
                                  axis.text = element_text(size = use_txt_size[sn])
                   )

comb_pl2 <- cowplot::plot_grid(abs_pl, percentage_pl, nrow = 2, align = "v")

cowplot::save_plot(filename = file.path(result_dir_path[[sn]],
                paste0("hk_genes_proportion.pdf")), plot = comb_pl2, 
                   ncol = 1, nrow = 2, dpi = 600, base_width = 10)

## Moved to the end to include GO terms dotplot
# comb_pl <- cowplot::plot_grid(comb_pl1, comb_pl2, ncol = 2, rel_widths = c(1,0.8), align = "h", 
#                               labels = "AUTO", label_size = 16, label_colour = "black", 
#                               hjust = c(0.08, -0.1), vjust = c(1.1, 1.1))
# 
# cowplot::save_plot(filename = file.path(result_dir_path[[sn]],
#                 paste0("extra_figure_human.pdf")), plot = comb_pl,
#                    ncol = 2, dpi = 600, base_width = 8, base_height = 7)

```





### For paper: IQW-TPM-PhastCons plots {#paper-iqw-tpm-plots}



```{r paper-iqw-tpm-plots, warning=FALSE, message=FALSE, eval=TRUE}


use_txt_size <- c(40)
names(use_txt_size) <- sample_names


####
if(do_IQW_TPM_plots){
    message("Task: Producing IQW_TPM_PhastCons scores combined plot")
    for(sn in sample_names){
        stopifnot(check_and_create_dir(result_dir_path[[sn]]))
        pl_iqw <- get_iqw_ord_plot(iqw = TRUE, y_axis_text = TRUE, 
                    samarth_df = samarth_df[[sn]], text_size = use_txt_size[sn],
                    seqs_clust = seqs_clusters_as_list_ordered[[sn]],
                    use_suffix = "", use_notch = FALSE)
        ##
        pl_tpm <- get_iqw_ord_plot(tpm = TRUE, y_axis_text = FALSE, 
                    samarth_df = samarth_df[[sn]], text_size = use_txt_size[sn],
                    seqs_clust = seqs_clusters_as_list_ordered[[sn]],
                    use_suffix = "", use_notch = FALSE)
        ##
        seqs_clust <- seqs_clusters_as_list_ordered[[sn]]
        clust_lens <- unlist(lapply(seqs_clust, length))
        clust_labels <- paste(1:length(seqs_clust),
                          paste0("(n=", clust_lens, ")"), sep="_")
        clr <- RColorBrewer::brewer.pal(4, "Dark2")
        pl_tspec <- ggplot2::ggplot(samarth_df[[sn]],
                     aes(y=fct_reorder(clust_ID, IQW,
                                       .fun = median,
                                       .desc = TRUE),
                         x=tissueSpecScore)) +
            ggplot2::geom_boxplot(outlier.size = 1, width = 0.5, notch = FALSE,
                         color = "black", fill = clr[4]) +
            # scale_x_log10() +
            xlab(expression(paste("Tissue Specificity (", tau, ")"))) +
            ylab("Clusters") +
            ggplot2::xlim(c(0,1)) + 
            # scale_y_discrete(labels = rev(clust_labels)) +
            theme_bw() +
            theme(panel.grid = element_blank(),
                  # axis.title = element_text(colour = "black", size = use_txt_size[sn]),
                  axis.text.x = element_text(colour = "black", #angle = 45,
                                       size = use_txt_size[sn], vjust = 0.5, hjust = 0.5),
                  axis.title.y=element_blank(),
                  axis.text.y=element_blank(),
                  axis.ticks.y=element_blank()) +
            ggeasy::easy_all_text_size(size=use_txt_size[sn]) + 
            ggeasy::easy_x_axis_labels_size(size=use_txt_size[sn])
        ##
        ## IQW ordered plots
        # iqw_tpm_ord_pls <- pl_iqw | pl_tpm
        iqw_tpm_phast_ord_pls <- pl_iqw | pl_tpm | pl_tspec
        perSample_pl[[sn]] <- iqw_tpm_phast_ord_pls
        
        title_str <- paste0("Sample_", sn, "_IQW_TPM_TissSpec_plot")
        # title_str <- paste0("Sample_", sn, "_IQW_TPM_plot")
        pl_w_title <- perSample_pl[[sn]] + plot_annotation(title = title_str)
        cowplot::save_plot(filename = file.path(result_dir_path[[sn]],
                paste0(title_str, "_paper.pdf")),
                plot = perSample_pl[[sn]],
                base_height = 12, base_width = 14
                )
        # cowplot::save_plot(filename = file.path(result_dir_path[[sn]],
        #         paste0(title_str, ".png")),
        #         plot = pl_w_title,
        #         base_height = 17, base_width = 14
        #         )
        # ggsave(filename = file.path(result_dir_path[[sn]],
        #        paste0(title_str, ".pdf")),
        #        plot = pl_w_title,
        #        width = 10, height = 7)
        # ggsave(filename = file.path(result_dir_path[[sn]],
        #        paste0(title_str, ".png")),
        #        plot = pl_w_title, device = "png", dpi = 300,
        #        width = 10, height = 7)
        # print(pl_w_title)
        
    }
    
}else{
    message("do_iqw_tpm_plot is FALSE")
}


```


### For paper: Sequence logos of cluster architectures {#paper-arch-seqlogos}

Sequence logos of clusters ordered by their median interquantile width (ascending order). These are included as part of the combined panels.

```{r paper-seqlogos, eval=TRUE}

#fig.width=11, fig.height=10, out.width="1200px", out.height="800px",

##
if(do_plot_arch){
    for(sn in sample_names){
        stopifnot(check_and_create_dir(result_dir_path[[sn]]))
        ##
        message("Generating architectures for clusters of sequences...")
        fname <- file.path(result_dir_path[[sn]],
                           paste0("Architectures_0-max_paper.pdf"))
        iter5_human_arch_list <- lapply(seq_along(perSample_archR_clusts[[sn]]), 
          function(y){
          x <- perSample_archR_clusts[[sn]][[y]]
          pl <- archR::plot_ggseqlogo_of_seqs(as.character(human_result[[sn]]$rawSeqs[x]), 
            pos_lab = -50:150, bits_yax = "auto", title = NULL)
          pl <- pl + theme_classic() + 
                     theme(axis.text = element_text(size=use_txt_size),
                     axis.text.x = element_text(angle=0, vjust = 0.5, hjust = 0.5),
                     axis.text.y = element_text(hjust = -5),
                     # axis.text.y.left = element_text(hjust = -5), 
                     # axis.text.y.left = element_text(vjust = 0.5, hjust = 1.5), 
                     axis.title.y = element_text(size=use_txt_size),# axis.line.y.right = element_blank(),
                     axis.title.y.left = element_text(margin = unit(c(0, 0, 0, 0.1), "cm")),
                     axis.title.y.right = element_text(margin = unit(c(0, 0, 0, 0.5), "cm")),
                     axis.ticks.length.y.left = unit(0.15, "cm"),
                     axis.ticks.length.y.right = unit(0.00, "cm"),
                     axis.ticks.length.x.bottom = unit(0.2, "cm"),
                     axis.ticks = element_line(size=1),
                     axis.ticks.y.right = element_blank(),
                     # plot.margin = unit(c(0,0,0,0), "cm")
                     plot.margin = unit(c(-1,0.1,0,0.4), "cm")
                     ) +
            ggplot2::scale_y_continuous(breaks = seq(0.0, 2.0, by = 0.5),
                                        labels = scales::number_format(accuracy = 0.1),
                                        sec.axis = dup_axis(name = paste0("C",y), 
                                                            labels = NULL))
          if(y == 1){
                pl <- pl + theme(plot.margin = unit(c(2,0,0,0.4), "cm"))
            }else{
                pl <- pl + theme(plot.margin = unit(c(2,0,0,0.4), "cm"))
            }
          
          # pl <- pl + theme(axis.text = element_text(size=use_txt_size[sn]), 
          #            # axis.text.x = element_text(angle=0, vjust = 2, hjust = 0.5),
          #            # axis.text.x = element_text(angle=90, vjust = 0, hjust = 0),
          #            axis.text.y = element_text(vjust = 0.5),
          #            axis.title.y = element_text(size=use_txt_size[sn]),
          #            axis.ticks.length = unit(0.04, "cm"),
          #            plot.margin = unit(c(0,0.1,-0.4,0.1), "cm")) +
          #   ggplot2::scale_y_continuous(sec.axis = dup_axis(name = paste0("C",y), labels = NULL))
          # # pl + theme(plot.margin = unit(c(0,0.2,-0.5,0.1), "cm"))
          # # pl + theme(plot.margin = unit(c(0,0,-0.3,0), "cm"))
         
          pl
        })
        # print(length(iter5_dm_arch_list))
        
        r1c1 <- cowplot::plot_grid(plotlist = iter5_human_arch_list, ncol = 1)
        cowplot::save_plot(fname, plot = r1c1, limitsize = FALSE, 
                           base_width = 30, base_height = 3,
                           nrow = length(seqs_clusters_as_list_ordered[[sn]]))
        
        # cowplot::ggsave2(fname, plot= r1c1, width=25, height=60, units="cm",
        #       dpi = 600, limitsize = FALSE)
        
        ## save PNGs
        # for(p in 1:length(iter5_human_arch_list)){
        #     this_result_dir_path <- file.path(result_dir_path[[sn]], "arch_png")
        #     stopifnot(check_and_create_dir(this_result_dir_path))
        #     fname <- file.path(this_result_dir_path, 
        #             paste0("Architecture_clust", p, "_0-max.png"))
        #     cowplot::ggsave2(fname, plot= iter5_human_arch_list[[p]], 
        #       width=25, height=3, units="cm", dpi = 300)
        # }
        # r1c1
        perSample_arch_combined[[sn]] <- r1c1
        perSample_arch[[sn]] <- iter5_human_arch_list
        
        if(file.exists(fname)){
            knitr::include_graphics(fname)
        }
    }
}else{
    message("do_plot_arch is FALSE")
}
##



```


### For paper: All of it together

```{r paper-all-together, warning=FALSE, message=FALSE, echo=FALSE, eval=TRUE}

## fig.width=18, fig.height=12, warning=FALSE,results='hide'
## use cowplot to arrange plots



for(sn in sample_names){
    
    stopifnot(check_and_create_dir(result_dir_path[[sn]]))
    
    
    # clust_labs <- unlist(lapply(seq_along(perSample_archR_clusts[[sn]]),
    #   function(x){
    #     paste0(x, "_(n=", length(perSample_archR_clusts[[sn]][[x]]), ")")
    #     }))
    
    clustwise_anno <- lapply(perSample_archR_clusts[[sn]], function(x){
        foo_anno <- ChIPseeker::annotatePeak(perSample_CAGEobj[[sn]][x,],
                                             tssRegion=c(-500, 100),
                                             TxDb = TxDb.Hsapiens.UCSC.hg19.ensGene,
                                             annoDb="org.Hs.eg.db")
    })
    
    names(clustwise_anno) <- seq(1, length(perSample_archR_clusts[[sn]]))
    
    ## Solution using custom plotting
    sam <- dplyr::bind_rows(lapply(clustwise_anno, function(x) x@annoStat), .id = "clust")
    check_id_downstream <- vapply(unique(sam$Feature), 
                               function(x) if(length(grep("Downstream", x)) > 0) 1 else 0, 
                               numeric(1))
    which_id_downstream <- which(check_id_downstream == 1)
    colrs <- RColorBrewer::brewer.pal(n = length(levels(unique(sam$Feature))), name = "Paired")
    names(colrs) <- levels(unique(sam$Feature))
    names(colrs)[which_id_downstream] <- "Downstream"
    ## to check that we did not accidentally alter any other feature name instead of "downstream"
    check_id_downstream2 <- vapply(unique(sam$Feature), 
                               function(x) if(length(grep("Downstream", x)) > 0) 1 else 0, 
                               numeric(1))
    which_id_downstream2 <- which(check_id_downstream2 == 1)
    stopifnot(which_id_downstream == which_id_downstream2)
    ## ^to make it shorter. explain it in the legend/text.
    
    
    clustwise_annobar <- ggplot(sam, 
      aes(y = fct_rev(reorder(clust, as.numeric(clust))), x = Frequency, fill = Feature)) + 
      geom_bar(stat = "identity", width = 0.6, position = position_fill(reverse=TRUE)) + 
      ggplot2::scale_fill_manual(name = "", values = colrs) +
      ggplot2::theme_classic() + 
      ggplot2::theme(axis.text.y = element_blank(),
                     axis.ticks.length.y.left = unit(0.1, units = "cm"),
                     axis.ticks.length.x.bottom = unit(0.1, units = "cm"),
                     axis.text.x.bottom = element_text(size = use_txt_size[sn]),
                     axis.title.x.bottom = element_text(size = use_txt_size[sn]),
                     legend.position = "bottom",
                     # legend.justification = 
                     legend.text = element_text(size = use_txt_size[sn])
                     ) + 
      ggplot2::guides(fill = guide_legend(nrow = 3, byrow = TRUE
                                         )) +
      ggplot2::ylab(NULL) + 
      ggplot2::xlab("Proportion") +
      # ggplot2::scale_y_discrete(expand = c(0, 0.1))
      NULL
    
    ## Solution using ChIPseeker package function
    # names(clustwise_anno) <- paste0("C", seq(length(clustwise_anno)))
    # clustwise_annobar <- ChIPseeker::plotAnnoBar(clustwise_anno)
    # clustwise_annobar <- clustwise_annobar + 
    #             ggplot2::theme(text=element_text(size=18), 
    #                            axis.text.x = element_text(size = use_txt_size), 
    #                            axis.text.y = element_text(size = use_txt_size)
    #                            )
    
    ## We could possibly use the same colors as in the individual freq plots in
    ## the carousels. But, not doing that for now.
    # anno_terms_ord <- get_fixed_anno_ord()
    # use_colors <- get_named_colors(anno_terms_ord, palname = "Set1")
    # use_colors
    # clustwise_annobar <- clustwise_annobar + 
    #                      ggplot2::scale_fill_manual(values = use_colors)
    
    
    panel_pl <- cowplot::plot_grid(perSample_pl[[sn]],
                                    perSample_arch_combined[[sn]],
                                    clustwise_annobar,
                                    ncol = 3, 
                                    #labels = c('A', 'B'), vjust=1, hjust = 0,
                                    rel_widths = c(0.8, 0.85, 0.4),
                                    rel_heights = c(1, 2, 1),
                                    axis = "tb",
                                    align = "h"
                                    )

    
    
    cowplot::save_plot(filename = file.path(result_dir_path[[sn]], 
                                            paste0("human_figure_paper_", sn, ".pdf")),
                plot = panel_pl, ncol = 3, nrow = 15,
                base_height = 3, base_width = 20, limitsize=FALSE)
    # # print(panel_pl)
    # cowplot::save_plot(filename = file.path(result_dir_path[[sn]], "combined_panel.png"),
    #             plot = panel_pl, ncol = 3, #nrow = 10,
    #             base_height = 13, base_width = 10, limitsize=FALSE)
    
}





```

### For paper: GO terms enrichment


```{r}


## no ww signal/WW-box arch
arch_term <- "all_clusters"
clust_list <- list(c(1,1), c(1,3), c(1,4), c(1,5), c(1,6), 
                    c(1,9), c(1,10), c(1,11), c(1,12), c(1,13), c(1,14)
    )

go_res <- lapply(clust_list, function(x){
                clusterProfiler::enrichGO(perSample_geneList[[x[1]]][[x[2]]],
                    OrgDb = org.Hs.eg.db, ont = "all", pool = TRUE, 
                    keyType = "ENTREZID", 
                    pvalueCutoff = 0.05, qvalueCutoff = 0.1)
    })
use_names <- paste0("C", unlist(lapply(clust_list, function(x) x[2])))
stopifnot(length(use_names) == length(go_res))
names(go_res) <- use_names

compare_result <- clusterProfiler::merge_result(go_res)


go_term_fs <- 12
show_cats <- c(5, 10)
go_pl <- vector("list", length(show_cats))
for(i in seq_along(show_cats)){
    p1 <- dotplot(compare_result, showCategory = show_cats[i],
                          title = paste0("Comparing ",
                              unlist(strsplit(arch_term, "_")), 
                              " architectures"),
                          font.size = go_term_fs)
    pl <- p1 + DOSE::theme_dose(font.size = go_term_fs) +
            ggplot2::scale_y_discrete(labels = scales::label_wrap(50)) +
            ggplot2::scale_color_gradient() + 
            # ggplot2::expand_limits(y = -1) + 
            # ggplot2::annotate("rect", fill = c("red", "blue"), alpha = 0.5, 
            #                 xmin = c(-Inf, 7.5), xmax = c(7.5,Inf),
            #                 ymin = -1, ymax = 0) +
            ggplot2::theme(title = element_text(size = go_term_fs),
                           legend.text = element_text(size = go_term_fs),
                           legend.title = element_text(size = go_term_fs))
    go_pl[[i]] <- pl
    cowplot::save_plot(
        filename = file.path(result_dir_path[[1]], paste0(arch_term, "_go_plot_top", show_cats[i], "_terms.pdf")), 
        plot = go_pl[[i]], 
        base_height = 5, base_width = 8)    
}
all_go_pl <- go_pl




## Combining for additional figure fo Hsapiens

comb_pl_top <- cowplot::plot_grid(comb_pl1, comb_pl2,  
    ncol = 2, 
    rel_widths = c(1,0.8), align = "h", 
    labels = "AUTO", label_size = 16, label_colour = "black",
    hjust = c(0.08, -0.1), vjust = c(1.1, 1.1))

comb_pl <- cowplot::plot_grid(comb_pl_top, all_go_pl[[1]], nrow = 2, 
                                rel_heights = c(0.35, 1), 
                                labels = c("", "C"), label_size = 16, 
                                label_colour = "black",
                                hjust = c(0.08, -0.1), vjust = c(1.1, 1.1))

cowplot::save_plot(filename = file.path(result_dir_path[[sn]],
                paste0("extra_figure_human.pdf")), plot = comb_pl,
                   ncol = 2, dpi = 300, base_width = 6.5, base_height = 15)


```



# Session Info

```{r sessionInfo, echo=FALSE}

sessionInfo()

```
