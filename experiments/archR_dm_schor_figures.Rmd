---
author: "Sarvesh Nikumbh"
date: '`r format(Sys.time(), "%d %B, %Y")`'
output: 
  bookdown::html_document2:
    code_folding: hide
    toc: true
    toc_float: true
    number_sections: true
    anchor_sections: true
    number_tables: true
  editor_options:
    chunk_output_type: console
params:
  use_title: "archR result analysis report for CTSS in RAL28"
  sample_name: "RAL28"
  iqw_order_by_median: true
  data_path_on_disk: ""
  result_path_on_disk: ""
  result_dir_name: ""
  do_plot_arch: true
  do_iqw_tpm_plots: true
  do_bedfile_write: true
title: "`r params$use_title`"
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(collapse=TRUE)

data_path <- file.path("data")
results_path <- file.path("results")

## Setup paths on disk
data_path_on_disk <- data_path
result_path_on_disk <- results_path

## paths specific to the organism
archR_org_data_path <- file.path(data_path, "drosophila-schor2017")
archR_org_results_path <- file.path(results_path, "drosophila-schor2017", 
                                    "with_archR_v0.1.8")
## The newly_processed folder contains results upon reprocessing the raw CAGE data 
## to mitigate the double application of 'removeFirstG' using CAGEr.
## This was caused due to removal of first G being already applied by the authors Schor et al. 2017 while the CAGEr processing pipeline that was used for processing CAGE data for all organisms accidentally re-applied this correction. 
## This resulted is the TGT architecture to be shifted upstream by 1 nucleotide, i.e.,
## instead of the G occurring at +1 (as expected), the T on its right appeared at +1 position.
## 

##
sample_name <- params$sample_name
result_dir_path <- file.path(params$result_path_on_disk, params$result_dir_name)
reordered <- params$reordered
dist_method <- params$dist_method
linkage <- params$linkage
topN_val <- params$topN_val
regularize_choice <- params$regularize
iteration <- params$archR_iteration
iqw_order_by_median <- params$iqw_order_by_median



#####
do_plot_seq_image <- params$do_plot_seq_image
do_plot_arch <- params$do_plot_arch
do_IQW_TPM_plots <- params$do_iqw_tpm_plots
do_bedfile_write <- params$do_bedfile_write


```



# Sample: `r sample_name` {#sample-name-section}

This file produces additional analyses plots for sample `r sample_name`, 
iteration `r iteration` of archR result.

## Parameter settings for this report

```{r param-settings}

params_df <- data.frame(param = names(params),
                        value = as.vector(unlist(params)))

knitr::kable(params_df)

```


```{r library, echo=FALSE, include=FALSE, message=FALSE}
seed_val <- 11992288
set.seed(seed_val)

library(BSgenome.Dmelanogaster.UCSC.dm6)     # Bioconductor v1.4.1
library(TxDb.Dmelanogaster.UCSC.dm6.ensGene) # Bioconductor v3.12.0
library(org.Dm.eg.db)                        # Bioconductor v3.14.0

## Package version annotations using RStudio addin annotator
## https://luisdva.github.io/rstats/annotater/
# library(CAGEr, lib.loc = "/usr/local/lib/R/site-library") # Bioconductor v1.34.0
library(readr)                               # CRAN v2.0.2
library(reshape2)                            # CRAN v1.4.4
library(ggplot2)                             # CRAN v3.3.5
library(forcats)                             # CRAN v0.5.1
library(cowplot)                        # CRAN v1.1.1
library(patchwork)
library(wesanderson)
## ^ for plotting
## 
## GenomeInfoDb now available in sarvesh's user library
library(GenomeInfoDb)                        # Bioconductor v1.30.0
library(ChIPseeker)                          # Bioconductor v1.30.0
library(clusterProfiler)                     # Bioconductor v4.2.0
library(DT)                                  # CRAN v0.19
library(scales)


## 
library(GenomicScores) ## for phastcons scores
library(PWMEnrich)                           # Bioconductor v4.30.0
library(PWMEnrich.Dmelanogaster.background)  # [Drosophila_melanogaster_Data::NA/NA] v4.27.1
data(MotifDb.Dmel.PFM, package = "PWMEnrich.Dmelanogaster.background")

library(DECIPHER)

```





## Plots for sections marked TRUE are included in this report.

```{r source-helper-funcs, include=FALSE}


source('helper-funcs.R')

```

## Setting up variables

```{r setup-variables}

sample_names <- paste0("RAL28_", c("2_to_4", "6_to_8", "10_to_12_sample12"))

archR_best_run <- vector("list", length(sample_names))
names(archR_best_run) <- sample_names

dm_2017_result <- vector("list", length(sample_names))
names(dm_2017_result) <- sample_names

dm_schor2017_bed_info <- vector("list", length(sample_names))
names(dm_schor2017_bed_info) <- sample_names

seqs_clusters_as_list <- vector("list", length(sample_names))
names(seqs_clusters_as_list) <- sample_names

seqs_clusters_as_list_ordered <- vector("list", length(sample_names))
names(seqs_clusters_as_list_ordered) <- sample_names

perSample_CAGEobj <- vector("list", length(sample_names))
names(perSample_CAGEobj) <- sample_names

perSample_peakAnno <- vector("list", length(sample_names))
names(perSample_peakAnno) <- sample_names

samarth_df <- vector("list", length(sample_names))
names(samarth_df) <- sample_names
##
perSample_phastCons_scores <- vector("list", length(sample_names))
names(perSample_phastCons_scores) <- sample_names

##
## lists storing plots
## 
## store iqw+tpm plots
perSample_pl <- vector("list", length(sample_names)) 
names(perSample_pl) <- sample_names

## store architectures' plots
perSample_arch <- vector("list", length(sample_names)) 
names(perSample_arch) <- sample_names

## store architectures' plots combined
perSample_arch_combined <- vector("list", length(sample_names)) 
names(perSample_arch_combined) <- sample_names


perSample_arch_posStrand <- vector("list", length(sample_names)) 
names(perSample_arch_posStrand) <- sample_names

perSample_arch_negStrand <- vector("list", length(sample_names)) 
names(perSample_arch_negStrand) <- sample_names


## store result_directory path
result_dir_path <- vector("list", length(sample_names)) 
names(result_dir_path) <- sample_names

## store go plots
perSample_go <- vector("list", length(sample_names)) 
names(perSample_go) <- sample_names


## store clusters
perSample_archR_clusts <- vector("list", length(sample_names)) 
names(perSample_archR_clusts) <- sample_names

## store overlaps info
perCluster_overlaps_perSample <- vector("list", length(sample_names)) 
names(perCluster_overlaps_perSample) <- sample_names

################################################################################
## Per section some variables need to be set. These are done here
```



```{r setup-cager-obj}
txdb <- TxDb.Dmelanogaster.UCSC.dm6.ensGene
## CAGEr object processing


# read TagClusters information from corresponding RDS file for sample
# All samples in one RDS object
# cager_obj <- "/mnt/storage/cage_datasets/drosophila_melanogaster/dm6/cager_objects/myCAGEset_Normalised_TagC_dmelanogaster_dm6_Schor_sample_processedMergedSamples.rds"



ok_chr_names <- c("chr2L", "chr2R", "chr3L", "chr3R", "chrM",  "chrX",  "chrY")

for(sn in sample_names){
    result_dir_path[[sn]] <- file.path(archR_org_results_path, 
                                       paste0(sn, "_results"))
}





```

```{r read-result-and-TCbed}

## RAL28, 2-4h, 1e-08, FTTF seems satisfactory
##

for(sn in sample_names){
  archR_best_run[[sn]] <- 
  file.path(archR_org_results_path, 
            paste0("archR_result_drosophila_schor2017_", sn,
                   "_modSelType_stability_chunkSize_5000", 
                   "_bound_1e-08_aggl_ward.D_dist_euclid_collate_FTTTF"))
  if(file.exists(archR_best_run[[sn]])){
    dm_2017_result[[sn]] <- readRDS(file.path(archR_best_run[[sn]],
                                              "archRresult.rds"))
  }else{
    stop("Check if file exists. ", archR_best_run[[sn]])
  }
  ## Bed Info -- IQW and dominant TPM values
  bed_fname <- file.path(archR_org_data_path, 
                         paste0("dm6_samarth_schor_et_al_TC_sample_", sn, "_minTPM1.bed"))
  
  dm_schor2017_bed_info[[sn]] <- read.delim(file = bed_fname,
                              sep = "\t", header = TRUE,
                              col.names = c("chr", "start", "end", "IQW", 
                                            "domTPM", "strand"))
}

```

## Prepare per sample GRanges from CAGEr object

```{r make-cager-obj, echo=FALSE}

## newly processed CAGE data is already a GRanges object

# myCAGEobject <- readRDS(cager_obj)

# CAGEr::cumulativeCTSSdistribution(myCAGEobject, clusters = "tagClusters")
# 
# CAGEr::quantilePositions(myCAGEobject, clusters = "tagClusters", qLow = 0.1, qUp = 0.9)


## Per sample TCs

for(sn in sample_names){
    message("SAMPLE: ", sn)
    ## With newly_processed data, TCs for individual samples are in separate files
    cager_obj <- file.path(archR_org_data_path, 
                           paste0("dm6_samarth_schor_et_al_TC_sample_", sn, "_minTPM1.rds"))
    myCAGEobject <- readRDS(cager_obj)
    result_dir_path <-file.path(archR_org_results_path, 
                                paste0(sn, "_results"))
    stopifnot(check_and_create_dir(result_dir_path))
    gr_CAGEobj_perSample_fname <- file.path(result_dir_path, 
                                  paste("cagerObj", sn, "gr.rds", sep="_"))
    if(!file.exists(gr_CAGEobj_perSample_fname)){
        # cli::cli_alert_info("Preparing new GRanges obj from CAGEr object")
        # myCAGEobject_thisSample <-
        #     CAGEr::tagClusters(myCAGEobject, samples = sn, 
        #                 returnInterquantileWidth = TRUE, qLow = 0.1, qUp = 0.9)
    
        # ## Keeping only standard chromosomes
        # message("Keeping only standard chromosomes")
        # ok_idx <- which(myCAGEobject_thisSample$chr %in% ok_chr_names)
        # myCAGEobject_thisSample <- myCAGEobject_thisSample[ok_idx,]
        
        ## Filter >= 1TPM
        message("Filtering >= 1TPM")
        tcGR <- myCAGEobject[
          which(myCAGEobject$tpm.dominant_ctss >= 1),]
        
        ## Keeping only standard chromosomes
        message("Keeping only standard chromosomes")
        tcGR <- GenomeInfoDb::keepStandardChromosomes(tcGR,
                                        species = names(genomeStyles())[5],
                                        pruning.mode = "coarse")
        
        ##
        message("Turning into GRanges object around the dominant tss...")
        gr_myCAGEobject_thisSample <- GenomicRanges::GRanges(seqnames = seqnames(tcGR),
                                   ranges = IRanges::IRanges(start=tcGR$dominant_ctss, width=1),
                                   strand = tcGR@strand)
        
        seqlengths(gr_myCAGEobject_thisSample) <- seqlengths(BSgenome.Dmelanogaster.UCSC.dm6)[names(seqlengths(tcGR))]
        
        gr_myCAGEobject_thisSample <- trim(gr_myCAGEobject_thisSample)
        
        # gr_myCAGEobject_thisSample <-
        #     GenomicRanges::GRanges(
        #       seqnames = myCAGEobject_thisSample[,"chr"],
        #       ranges = IRanges::IRanges(
        #       start=myCAGEobject_thisSample[,"dominant_ctss"], width=2),
        #                            myCAGEobject_thisSample[,"strand"])
    
        # seqlengths(gr_myCAGEobject_thisSample) <- 
        #   seqlengths(BSgenome.Dmelanogaster.UCSC.dm6)[
        #     names(seqlengths(gr_myCAGEobject_thisSample))]
        gr_myCAGEobject_thisSample <- trim(gr_myCAGEobject_thisSample)
        saveRDS(file = gr_CAGEobj_perSample_fname, 
                object = gr_myCAGEobject_thisSample)
    }else{
        cli::cli_alert_info("Using saved GRanges obj from CAGEr object")
        gr_myCAGEobject_thisSample <- readRDS(gr_CAGEobj_perSample_fname)
    }
    perSample_CAGEobj[[sn]] <- gr_myCAGEobject_thisSample
    perSample_peakAnno[[sn]] <- ChIPseeker::annotatePeak(
                                    gr_myCAGEobject_thisSample,
                                    tssRegion=c(-500, 100),
                                    TxDb=txdb,
                                    annoDb="org.Dm.eg.db")

}


```

## Preparing PhastCons scores

```{r build-phastCons}
# GenomicScores::availableGScores()
## PhastCons scores with GenomicScores bioconductor package
phast <- GenomicScores::getGScores("phastCons27way.UCSC.dm6")
for(sn in sample_names){
    perSample_phastCons_scores[[sn]] <- 
      GenomicScores::score(phast, perSample_CAGEobj[[sn]])
}




```

## Order archR clusters by median IQ width {#prepare-objects}

By default, the clusters are ordered by their _median_ interquantile widths. 
One can choose to order by the _mean_ interquantile widths by setting paramater _iqw_order_by_median_ to `r FALSE`.

### Sample1 -- RAL28_2_to_4

```{r prepare-clusters-new-sample1}

sn <- 1
itr <- 5
use_aggl <- 'ward.D' 
use_dist <- 'cor'

#####
iter5_clusts_reord <- archR::collate_archR_result(
  result = dm_2017_result[[sample_names[sn]]], 
  iter = itr, clust_method = 'hc', aggl_method = use_aggl, 
  dist_method = use_dist, regularize = TRUE, topn = 50, 
  flag = list(debugFlag = FALSE, verboseFlag = TRUE), collate = FALSE, 
  return_order = TRUE)

clust_archR_ord_list <- archR::get_seqs_clust_list(
  seqs_clust_lab = dm_2017_result[[sample_names[[sn]]]]$seqsClustLabels[[itr]])

clust_hc_ord_list <- lapply(iter5_clusts_reord$order, function(x){
  clust_archR_ord_list[[x]]
})

ordered_arch_pl <- archR::plot_arch_for_clusters(
  seqs = dm_2017_result[[sample_names[[sn]]]]$rawSeqs, 
  clust_list = clust_hc_ord_list, pos_lab = -45:45, 
  xt_freq = 5, set_titles = FALSE, show = FALSE, bits_yax = "auto")

ordered_arch_pl2 <- lapply(rev(ordered_arch_pl), function(pl){
  pl <- pl + 
        ggplot2::theme(axis.text = ggplot2::element_text(size = 0), 
                       axis.text.x = ggplot2::element_text(
                         angle = 0, vjust = 2, hjust = 0.5),
                       axis.text.y = ggplot2::element_text(vjust = 0.5),
                       axis.title.y = ggplot2::element_text(size = 0),
                       axis.ticks.length = ggplot2::unit(0.00, "cm"),
                       plot.margin = ggplot2::unit(c(-0.1,0,-0.4,-0.4), "cm"))
})
sam_foo <- cowplot::plot_grid(plotlist = ordered_arch_pl2, ncol = 1)



use_cutk <- 18
result_dir_path <- file.path(archR_org_results_path,
                             paste0(sample_names[sn], "_results"))
stopifnot(check_and_create_dir(result_dir_path))
fname <- file.path(result_dir_path, paste0(sample_names[sn], "_dend_arch_list_",
                                           use_dist, "_", use_aggl, "_",
                                           use_cutk, "clusters"))

sam_foo2 <- plot_dend_arch(arch_plot = sam_foo, fname = fname, use_cutk = use_cutk, 
              clusts = iter5_clusts_reord, 
              lwd = 0.4, repel = TRUE, show_labels = TRUE, labels_track_height = 0.25,
              rect = TRUE, rect_fill = TRUE,
              color_labels_by_k = TRUE, plot_png = FALSE)


# sam_foo2

temp_clusts <- cutree(iter5_clusts_reord, k = use_cutk)
names(temp_clusts) <- NULL
## Make further few clusters
nCl <- length(unique(temp_clusts))
##  singleton clusters == 3, 1, 26, 2
##  
temp_clusts[26] <- temp_clusts[13] 
# ^ this is fine because we are reassigning 13 to another cluster
temp_clusts[c(13,15,24)] <- temp_clusts[11]
temp_clusts[2] <- temp_clusts[c(44)] # loose a compelete cluster, hence reassign it
temp_clusts[c(44)] <- temp_clusts[23]
temp_clusts[c(40,41)] <- temp_clusts[38]
temp_clusts[19] <- nCl + 1
temp_clusts[9] <- nCl + 2

# Re-plot with proper coloring that shows the manipulations in clusters
use_cutk <- 18
result_dir_path <- file.path(archR_org_results_path,
                             paste0(sample_names[sn], "_results"))
stopifnot(check_and_create_dir(result_dir_path))
fname2 <- file.path(result_dir_path, paste0(sample_names[sn], "_dend_arch_list_",
                                           use_dist, "_", use_aggl, "_",
                                           use_cutk, "clusters_final"))

## Also need to show alongside, how the final clusters' seqlogos look
clust_list <- lapply(unique(temp_clusts), function(x){which(temp_clusts == x)})
seqs_clusters_as_list[[sample_names[sn]]] <- archR::collate_clusters(clust_list, archR::get_seqs_clust_list(dm_2017_result[[sn]]$seqsClustLabels[[itr]]))
##

use_color <- scales::hue_pal()(length(unique(temp_clusts)))
sam_foo2 <- plot_dend_arch(arch_plot = sam_foo, fname = fname2, use_ht = 60,
               use_cutk = use_cutk,#length(unique(temp_clusts)), 
               clusts = iter5_clusts_reord, rect = TRUE, rect_fill = TRUE,
               label_cols = use_color[temp_clusts[iter5_clusts_reord$order]],
               k_colors = use_color, 
               clust_assignment = clust_list,
               new_clusts = seqs_clusters_as_list[[sample_names[sn]]],
               rawSeqs = dm_2017_result[[sample_names[sn]]]$rawSeqs,
               pos_lab = -45:45,
               palette = FALSE, plot_png = FALSE)

# sam_foo2

#####



cluster_medians_IQW <- unlist(lapply(seqs_clusters_as_list[[sample_names[sn]]], function(x){
    median(dm_schor2017_bed_info[[sample_names[sn]]]$IQW[x])
}))
cluster_means_IQW <- unlist(lapply(seqs_clusters_as_list[[sample_names[sn]]], function(x){
    mean(dm_schor2017_bed_info[[sample_names[sn]]]$IQW[x])
}))

if(iqw_order_by_median){
    ascending_order_IQW <- sort(cluster_medians_IQW, decreasing = FALSE,
                            index.return = TRUE)
}else{
    ascending_order_IQW <- sort(cluster_means_IQW, decreasing = FALSE,
                            index.return = TRUE)
}
##
seqs_clusters_as_list_ordered[[sample_names[sn]]] <- 
                      lapply(ascending_order_IQW$ix,
                              function(x){
                                  seqs_clusters_as_list[[sample_names[sn]]][[x]]
                              })

perSample_archR_clusts[[sn]] <- seqs_clusters_as_list_ordered[[sn]]

```

We use `r use_aggl` (linkage) with `r use_dist` for sample 1.

### Sample 2 -- RAL28_6_to_8

```{r prepare-clusters-new-sample2}

sn <- 2
itr <- 5
use_aggl <- 'complete' 
use_dist <- 'cor'

#####
iter5_clusts_reord <- archR::collate_archR_result(
  result = dm_2017_result[[sample_names[sn]]], 
  iter = itr, clust_method = 'hc', aggl_method = use_aggl, 
  dist_method = use_dist, regularize = FALSE, topn = 50, 
  flag = list(debugFlag = FALSE, verboseFlag = TRUE), collate = FALSE, 
  return_order = TRUE)

clust_archR_ord_list <- archR::get_seqs_clust_list(
  seqs_clust_lab = dm_2017_result[[sample_names[[sn]]]]$seqsClustLabels[[itr]])

clust_hc_ord_list <- lapply(iter5_clusts_reord$order, function(x){
  clust_archR_ord_list[[x]]
})

ordered_arch_pl <- archR::plot_arch_for_clusters(
  seqs = dm_2017_result[[sample_names[[sn]]]]$rawSeqs, 
  clust_list = clust_hc_ord_list, pos_lab = -45:45, 
  xt_freq = 5, set_titles = FALSE, show = FALSE, bits_yax = "auto")

ordered_arch_pl2 <- lapply(rev(ordered_arch_pl), function(pl){
  pl <- pl + 
        ggplot2::theme(axis.text = ggplot2::element_text(size = 0), 
                       axis.text.x = ggplot2::element_text(
                         angle = 0, vjust = 2, hjust = 0.5),
                       axis.text.y = ggplot2::element_text(vjust = 0.5),
                       axis.title.y = ggplot2::element_text(size = 0),
                       axis.ticks.length = ggplot2::unit(0.00, "cm"),
                       plot.margin = ggplot2::unit(c(-0.1,0,-0.4,-0.4), "cm"))
})
sam_foo <- cowplot::plot_grid(plotlist = ordered_arch_pl2, ncol = 1)

use_cutk <- 19
result_dir_path <- file.path(archR_org_results_path,
                             paste0(sample_names[sn], "_results"))
stopifnot(check_and_create_dir(result_dir_path))
fname <- file.path(result_dir_path, paste0(sample_names[sn], "_dend_arch_list_",
                                           use_dist, "_", use_aggl, "_",
                                           use_cutk, "clusters"))

sam_foo2 <- plot_dend_arch(arch_plot = sam_foo, fname = fname, use_cutk = use_cutk, 
              clusts = iter5_clusts_reord, 
              lwd = 0.4, repel = TRUE, show_labels = TRUE, labels_track_height = 0.25,
              rect = TRUE, rect_fill = TRUE,
              color_labels_by_k = TRUE, plot_png = FALSE)


# sam_foo2

temp_clusts <- cutree(iter5_clusts_reord, k = use_cutk)
temp_clusts_copy <- temp_clusts
names(temp_clusts) <- NULL
## Make further few clusters
nCl <- length(unique(temp_clusts))

temp_clusts[c(51,52,54:56)] <- nCl + 1
temp_clusts[c(4,6,46,47)] <- nCl + 2
temp_clusts[3] <- nCl + 3
temp_clusts[c(41)] <- temp_clusts[42]
temp_clusts[c(8,26,23,27,28,29)] <- temp_clusts[24]
temp_clusts[c(24)] <- temp_clusts[21] ##lost a cluster




# Re-plot with proper coloring that shows the manipulations in clusters
use_cutk <- 19
result_dir_path <- file.path(archR_org_results_path,
                             paste0(sample_names[sn], "_results"))
stopifnot(check_and_create_dir(result_dir_path))
fname2 <- file.path(result_dir_path, paste0(sample_names[sn], "_dend_arch_list_",
                                           use_dist, "_", use_aggl, "_",
                                           use_cutk, "clusters_final"))


## Also need to show alongside, how the final clusters' seqlogos look
clust_list <- lapply(unique(temp_clusts), function(x){which(temp_clusts == x)})
seqs_clusters_as_list[[sample_names[sn]]] <- archR::collate_clusters(clust_list, archR::get_seqs_clust_list(dm_2017_result[[sn]]$seqsClustLabels[[itr]]))
##

use_color <- scales::hue_pal()(length(unique(temp_clusts)))
sam_foo2 <- plot_dend_arch(arch_plot = sam_foo, fname = fname2, use_ht = 60,
               use_cutk = use_cutk,#length(unique(temp_clusts)), 
               clusts = iter5_clusts_reord, rect = TRUE, rect_fill = TRUE,
               label_cols = use_color[temp_clusts[iter5_clusts_reord$order]],
               k_colors = use_color, 
               clust_assignment = clust_list,
               new_clusts = seqs_clusters_as_list[[sample_names[sn]]],
               rawSeqs = dm_2017_result[[sample_names[sn]]]$rawSeqs,
               pos_lab = -45:45,
               palette = FALSE, plot_png = FALSE)

# use_color <- scales::hue_pal()(length(unique(temp_clusts)))
# sam_foo2 <- plot_dend_arch(arch_plot = sam_foo, fname = fname2, 
#                use_cutk = use_cutk,#length(unique(temp_clusts)), 
#                clusts = iter5_clusts_reord, rect = TRUE, rect_fill = TRUE,
#                label_cols = use_color[temp_clusts[iter5_clusts_reord$order]],
#                k_colors = use_color,
#                palette = FALSE, plot_png = FALSE)

# sam_foo2
#####


# ### factoextra::fviz_dend func showing rect for clusters shows 22 clusters at 
# ### 0.75, while original cutree gives the same clustering at 0.74.
# ### dendextend seems to be giving a fine answer, the fviz func seems to have a 
# ### small discrepancy
# ### 
# temp_clusts <- cutree(iter5_clusts_reord, h = 0.74)
# names(temp_clusts) <- NULL
# clust_list <- lapply(unique(temp_clusts), function(x){which(temp_clusts == x)})
# seqs_clusters_as_list[[sample_names[sn]]] <- archR::collate_clusters(clust_list, archR::get_seqs_clust_list(dm_2017_result[[sn]]$seqsClustLabels[[itr]]))
###


cluster_medians_IQW <- unlist(lapply(seqs_clusters_as_list[[sample_names[sn]]], function(x){
    median(dm_schor2017_bed_info[[sample_names[sn]]]$IQW[x])
}))
cluster_means_IQW <- unlist(lapply(seqs_clusters_as_list[[sample_names[sn]]], function(x){
    mean(dm_schor2017_bed_info[[sample_names[sn]]]$IQW[x])
}))

if(iqw_order_by_median){
    ascending_order_IQW <- sort(cluster_medians_IQW, decreasing = FALSE,
                            index.return = TRUE)
}else{
    ascending_order_IQW <- sort(cluster_means_IQW, decreasing = FALSE,
                            index.return = TRUE)
}
##
seqs_clusters_as_list_ordered[[sample_names[sn]]] <- 
                      lapply(ascending_order_IQW$ix,
                              function(x){
                                  seqs_clusters_as_list[[sample_names[sn]]][[x]]
                              })

perSample_archR_clusts[[sn]] <- seqs_clusters_as_list_ordered[[sn]]


```



We use `r use_dist` with `r use_aggl` (linkage) for sample 2.

### Sample 3 -- RAL28_10_to_12

```{r prepare-clusters-new-sample3}
#####
sn <- 3
itr <- 5
use_aggl <- 'ward.D' 
use_dist <- 'euclid'


iter5_clusts_reord <- archR::collate_archR_result(
  result = dm_2017_result[[sample_names[sn]]], 
  iter = itr, clust_method = 'hc', aggl_method = use_aggl, 
  dist_method = use_dist, regularize = TRUE, topn = 50, 
  flag = list(debugFlag = FALSE, verboseFlag = TRUE), collate = FALSE, 
  return_order = TRUE)

clust_archR_ord_list <- archR::get_seqs_clust_list(
  seqs_clust_lab = dm_2017_result[[sample_names[[sn]]]]$seqsClustLabels[[itr]])

clust_hc_ord_list <- lapply(iter5_clusts_reord$order, function(x){
  clust_archR_ord_list[[x]]
})

ordered_arch_pl <- archR::plot_arch_for_clusters(
  seqs = dm_2017_result[[sample_names[[sn]]]]$rawSeqs, 
  clust_list = clust_hc_ord_list, pos_lab = -45:45, 
  xt_freq = 5, 
  set_titles = FALSE, show = FALSE, bits_yax = "auto")

ordered_arch_pl2 <- lapply(rev(ordered_arch_pl), function(pl){
  pl <- pl + 
        ggplot2::theme(axis.text = ggplot2::element_text(size = 0), 
                       axis.text.x = ggplot2::element_text(
                         angle = 0, vjust = 2, hjust = 0.5),
                       axis.text.y = ggplot2::element_text(vjust = 0.5),
                       axis.title.y = ggplot2::element_text(size = 0),
                       axis.ticks.length = ggplot2::unit(0.00, "cm"),
                       plot.margin = ggplot2::unit(c(-0.1,0,-0.4,-0.4), "cm"))
})
sam_foo <- cowplot::plot_grid(plotlist = ordered_arch_pl2, ncol = 1)


use_cutk <- 16
result_dir_path <- file.path(archR_org_results_path,
                             paste0(sample_names[sn], "_results"))
stopifnot(check_and_create_dir(result_dir_path))
fname <- file.path(result_dir_path, paste0(sample_names[sn], "_dend_arch_list_",
                                           use_dist, "_", use_aggl, "_",
                                           use_cutk, "clusters"))

sam_foo2 <- plot_dend_arch(arch_plot = sam_foo, fname = fname, use_cutk = use_cutk, 
              clusts = iter5_clusts_reord, 
              lwd = 0.4, repel = TRUE, show_labels = TRUE, labels_track_height = 1.55,
              rect = TRUE, rect_fill = TRUE,
              color_labels_by_k = TRUE, plot_png = FALSE)


# sam_foo2

temp_clusts <- cutree(iter5_clusts_reord, k = use_cutk)
names(temp_clusts) <- NULL
## Make further few clusters
nCl <- length(unique(temp_clusts))
temp_clusts[28] <- nCl + 1
temp_clusts[31] <- nCl + 2
temp_clusts[36] <- nCl + 3
temp_clusts[24] <- nCl + 4
temp_clusts[26] <- nCl + 5
temp_clusts[c(12)] <- temp_clusts[11]
temp_clusts[5] <- temp_clusts[2]


# Re-plot with proper coloring that shows the manipulations in clusters
use_cutk <- 16
result_dir_path <- file.path(archR_org_results_path,
                             paste0(sample_names[sn], "_results"))
stopifnot(check_and_create_dir(result_dir_path))
fname2 <- file.path(result_dir_path, paste0(sample_names[sn], "_dend_arch_list_",
                                           use_dist, "_", use_aggl, "_",
                                           use_cutk, "clusters_final"))


## Also need to show alongside, how the final clusters' seqlogos look
clust_list <- lapply(unique(temp_clusts), function(x){which(temp_clusts == x)})
seqs_clusters_as_list[[sample_names[sn]]] <- archR::collate_clusters(clust_list, archR::get_seqs_clust_list(dm_2017_result[[sn]]$seqsClustLabels[[itr]]))
##

use_color <- scales::hue_pal()(length(unique(temp_clusts)))
sam_foo2 <- plot_dend_arch(arch_plot = sam_foo, fname = fname2, use_ht = 60,
               use_cutk = use_cutk,#length(unique(temp_clusts)), 
               clusts = iter5_clusts_reord, rect = TRUE, rect_fill = TRUE,
               label_cols = use_color[temp_clusts[iter5_clusts_reord$order]],
               k_colors = use_color, 
               clust_assignment = clust_list,
               new_clusts = seqs_clusters_as_list[[sample_names[sn]]],
               rawSeqs = dm_2017_result[[sample_names[sn]]]$rawSeqs,
               pos_lab = -45:45,
               palette = FALSE, plot_png = FALSE)


# use_color <- scales::hue_pal()(length(unique(temp_clusts)))
# sam_foo2 <- plot_dend_arch(arch_plot = sam_foo, fname = fname2, 
#                use_cutk = use_cutk,#length(unique(temp_clusts)), 
#                clusts = iter5_clusts_reord, rect = TRUE, rect_fill = TRUE,
#                label_cols = use_color[temp_clusts[iter5_clusts_reord$order]],
#                k_colors = use_color,
#                palette = FALSE, plot_png = FALSE)

# sam_foo2
#####


# clust_list <- lapply(unique(temp_clusts), function(x){which(temp_clusts == x)})
# seqs_clusters_as_list[[sample_names[sn]]] <- archR::collate_clusters(clust_list, archR::get_seqs_clust_list(dm_2017_result[[sn]]$seqsClustLabels[[itr]]))
###


cluster_medians_IQW <- unlist(lapply(seqs_clusters_as_list[[sample_names[sn]]], function(x){
    median(dm_schor2017_bed_info[[sample_names[sn]]]$IQW[x])
}))
cluster_means_IQW <- unlist(lapply(seqs_clusters_as_list[[sample_names[sn]]], function(x){
    mean(dm_schor2017_bed_info[[sample_names[sn]]]$IQW[x])
}))

if(iqw_order_by_median){
    ascending_order_IQW <- sort(cluster_medians_IQW, decreasing = FALSE,
                            index.return = TRUE)
}else{
    ascending_order_IQW <- sort(cluster_means_IQW, decreasing = FALSE,
                            index.return = TRUE)
}
##
seqs_clusters_as_list_ordered[[sample_names[sn]]] <- 
                      lapply(ascending_order_IQW$ix,
                              function(x){
                                  seqs_clusters_as_list[[sample_names[sn]]][[x]]
                              })

perSample_archR_clusts[[sn]] <- seqs_clusters_as_list_ordered[[sn]]

```

We use `r use_dist` with `r use_aggl` (linkage) for sample 3.



<br/><br/><br/><br/><br/><br/><br/><br/><br/><br/>
<br/><br/><br/><br/><br/><br/><br/><br/><br/><br/>
<br/>
<br/><br/><br/><br/><br/><br/><br/><br/><br/><br/>
<br/><br/><br/><br/><br/><br/><br/><br/><br/><br/>
<br/>
<br/><br/><br/><br/><br/><br/><br/><br/><br/><br/>
<br/><br/><br/><br/><br/><br/><br/><br/><br/><br/>
<br/>


```{r make-df-from-bed}

for(sn in sample_names) {
    clust_lens <- unlist(lapply(perSample_archR_clusts[[sn]], length))
    message("Ordered list lengths: ", paste(clust_lens, collapse = " "))
    message("Original list lengths:", 
      paste(unlist(lapply(seqs_clusters_as_list[[sn]], length)), collapse = " "))
  
  
    ##
    clust_lab <- rep("0", length(dm_2017_result[[sn]]$rawSeqs))
    clust_names <- sort(as.character(1:length(perSample_archR_clusts[[sn]])))
    for(i in seq_along(perSample_archR_clusts[[sn]])){
        clust_lab[perSample_archR_clusts[[sn]][[i]] ] <- clust_names[i]
    }
  
  
    ### Get DF of BED information
    samarth_df[[sn]] <- data.frame(chr = dm_schor2017_bed_info[[sn]]$chr, 
                             start = dm_schor2017_bed_info[[sn]]$start,
                             end = dm_schor2017_bed_info[[sn]]$end, 
                             strand = dm_schor2017_bed_info[[sn]]$strand,
                             IQW = dm_schor2017_bed_info[[sn]]$IQW,
                             domTPM = dm_schor2017_bed_info[[sn]]$domTPM,
                             phast = perSample_phastCons_scores[[sn]],
                             clust_ID = clust_lab)
}


```





## Cluster-wise BED files {#per-cluster-bedfiles}


```{r write-bed-files, collapse=FALSE, results='asis', comment='', message=FALSE}

if(do_bedfile_write){
    message("Task: Write cluster-wise BED files to disk")
    for(sn in sample_names){
        result_dir_path <-file.path(archR_org_results_path, 
                                paste0(sn, "_results"))
        stopifnot(check_and_create_dir(result_dir_path))
        ##
        bedFilesPath <- file.path(result_dir_path, "Cluster_BED_tracks")
        stopifnot(check_and_create_dir(bedFilesPath))
        
        message("Writing cluster BED track files at:", bedFilesPath)
        ##
        #### Write bed to disk -- each cluster in a separate bed file
        cat(paste0("\n\n### Individual cluster track BED files [", sn, "]\n\n"))
        for(lo in seq_along(perSample_archR_clusts[[sn]])){
            ##
            bedFilename <- file.path(bedFilesPath,
                                  paste0("dm_schor2017_TC_sample_", sn, 
                                  "_cluster", lo, ".bed"))
            # print(bedFilename)
            seq_ids <- perSample_archR_clusts[[sn]][[lo]]
            limit_df <- samarth_df[[sn]][seq_ids,]
            track.name <- paste0(sn, "_dm6_", "clust", lo)
            write_as_track_bed(limit_df, seq_ids, track_name = track.name, 
                               bedFilename = bedFilename)
            dload_text <- xfun::embed_file(path = bedFilename,  
                        text = paste("Download coordinates for cluster", lo, " as browser track"))
            cat(paste0("\n<", dload_text$name," href=\"", dload_text$attribs$href, "\" download=\"", dload_text$attribs$download, "\">", dload_text$children[[1]][1],
                "</a>\n"))
        }
        #####
        message("Preparing strand-separated files")
        ## Strand-wise separate files per cluster
        cat(paste0("\n\n### Strand-separated individual cluster track BED files[", sn, "]\n\n"))
        for(lo in seq_along(perSample_archR_clusts[[sn]])){
            ## plus strand
            bedFilename_plus <- file.path(bedFilesPath,
                                paste0("dm_schor2017_TC_sample_", sn, 
                                  "_cluster", lo, "_plus_strand.bed"))
            ##
            chosen_idx_plus_strand <- get_strand_specific_indices(df = samarth_df[[sn]],
                                seq_ids_in_clust = perSample_archR_clusts[[sn]][[lo]],
                                strand_val = "+")
            ##
            if(length(chosen_idx_plus_strand) < 1){
              cat(paste0("<a href= >Empty",   "</a>"))
            }else{
            ##
              limit_df <- samarth_df[[sn]][chosen_idx_plus_strand,]
              track.name <- paste0(sn, "_dm6_", "clust", lo, "_plus_strand")
              write_as_track_bed(limit_df, chosen_idx_plus_strand, track_name = track.name, 
                                 bedFilename = bedFilename_plus)
              dload_text <- xfun::embed_file(bedFilename_plus, 
                          text = paste("Download coordinates for cluster", 
                                       lo, "(+ strand) as browser track"))
              cat(paste0("\n<", dload_text$name," href=\"", dload_text$attribs$href, "\" download=\"", dload_text$attribs$download, "\">", dload_text$children[[1]][1],
                  "</a>,  "))
            }
            ## minus strand
            bedFilename_minus <- file.path(bedFilesPath,
                                     paste0("dm_schor2017_TC_sample_",
                                            sn, "_cluster",
                                            lo, "_minus_strand.bed"))
            ##
            ##
            chosen_idx_minus_strand <- get_strand_specific_indices(df = samarth_df[[sn]],
                                seq_ids_in_clust = perSample_archR_clusts[[sn]][[lo]],
                                strand_val = "-")
            ##
            if(length(chosen_idx_minus_strand) < 1){
              cat(paste0("<a href= >Empty",   "</a>\n"))
            }else{
              limit_df <- samarth_df[[sn]][chosen_idx_minus_strand,]
              track.name <- paste0(sn, "_dm6_", "clust", lo, "_plus_strand")
              write_as_track_bed(limit_df, chosen_idx_minus_strand, track_name = track.name, 
                                 bedFilename = bedFilename_minus)
              dload_text <- xfun::embed_file(bedFilename_minus, 
                    text = paste("Download coordinates for cluster", 
                                       lo, "(- strand) as browser track"))
              cat(paste0("<", dload_text$name," href=\"", dload_text$attribs$href, "\" download=\"", dload_text$attribs$download, "\">", dload_text$children[[1]][1], "</a>\n"))
            }
            ##
        }
    }
    ##
    dload_all <- xfun::embed_dir(bedFilesPath, 
              text = paste("Download all clusters as separate browser track files (zip)"))
        cat(paste0("### All cluster track files (one zipped folder of all BED files)\n\n"))
        cat(paste0("\n<", dload_all$name," href=\"", dload_all$attribs$href, "\" download=\"", dload_all$attribs$download, "\">", dload_all$children[[1]][1],
                "</a>\n"))
    ##
}else{
    message("do_bedfile_write is FALSE")
}

```


## IQW-TPM-PhastCons plots {#iqw-tpm-plots}



```{r iqw-tpm-plots, warning=FALSE, message=FALSE}

suffix_label <- c("X", "Y", "Z")
names(suffix_label) <- sample_names
use_txt_size <- 14
####
if(do_IQW_TPM_plots){
    message("Task: Producing IQW_TPM_PhastCons scores combined plot")
    for(sn in sample_names){
        result_dir_path <-file.path(archR_org_results_path, 
                                paste0(sn, "_results"))
        stopifnot(check_and_create_dir(result_dir_path))
        pl_iqw <- get_iqw_ord_plot(iqw = TRUE, y_axis_text = TRUE, 
                                   use_notch = FALSE, text_size = use_txt_size,
                                samarth_df = samarth_df[[sn]], 
                                seqs_clust = perSample_archR_clusts[[sn]], 
                                use_suffix = suffix_label[sn])
        # pl_iqw <- pl_iqw + ggeasy::easy_all_text_size(size=18) +
        #           NULL +
        #           ggeasy::easy_y_axis_labels_size(size=18) +
        #           ggeasy::easy_x_axis_labels_size(size=18) +
        #           NULL
        ##
        pl_tpm <- get_iqw_ord_plot(tpm = TRUE, y_axis_text = FALSE,
                                   use_notch = FALSE, text_size = use_txt_size,
                    samarth_df = samarth_df[[sn]], 
                    seqs_clust = perSample_archR_clusts[[sn]], 
                    use_suffix = suffix_label[sn])
        # pl_tpm <- pl_tpm + ggeasy::easy_all_text_size(size=18) +
        #           NULL +
        #           # ggeasy::easy_y_axis_labels_size(size=14) +
        #           ggeasy::easy_x_axis_labels_size(size=14) +
        #           NULL
        ##
        pl_phast <- get_iqw_ord_plot(phast = TRUE, y_axis_text = FALSE, 
                                     use_notch = FALSE, text_size = use_txt_size,
                    samarth_df = samarth_df[[sn]], 
                    seqs_clust = perSample_archR_clusts[[sn]], 
                    use_suffix = suffix_label[sn])
        # pl_phast <- pl_phast + ggeasy::easy_all_text_size(size=18) + 
        #           NULL +
        #           # ggeasy::easy_y_axis_labels_size(size=18) +
        #           ggeasy::easy_x_axis_labels_size(size=18) +
        #           NULL
        ## IQW ordered plots
        iqw_tpm_ord_pls <- pl_iqw | pl_tpm
        
        iqw_tpm_phast_ord_pls <- pl_iqw + pl_tpm + pl_phast 
        # iqw_tpm_phast_ord_pls <- cowplot::plot_grid(pl_iqw,
        #                                             NULL,
        #                                             pl_tpm,
        #                                             NULL,
        #                                             pl_phast,
        #                                             ncol = 5,
        #                                             align = "h",
        #                                             rel_widths = c(1, 0.05, 0.7, 0.05, 0.7))
        
        perSample_pl[[sn]] <- iqw_tpm_phast_ord_pls
        # perSample_pl[[sn]] <- list(pl_iqw, pl_tpm, pl_phast)
        
        title_str <- paste0("Sample_", sn, "_IQW_TPM_phast_plot")
        pl_w_title <- iqw_tpm_phast_ord_pls + plot_annotation(title = title_str)
        cowplot::save_plot(filename = file.path(result_dir_path,
                paste0(title_str, ".pdf")),
                plot = pl_w_title, 
                base_height = 12, base_width = 14
                )
        cowplot::save_plot(filename = file.path(result_dir_path,
                paste0(title_str, ".png")),
                plot = pl_w_title,
                base_height = 17, base_width = 8
                )
        # ggsave(filename = file.path(result_dir_path,
        #        paste0(title_str, ".pdf")),
        #        plot = pl_w_title,
        #        width = 10, height = 7)
        # ggsave(filename = file.path(result_dir_path,
        #        paste0(title_str, ".png")),
        #        plot = pl_w_title, device = "png", dpi = 300,
        #        width = 10, height = 7)
        # print(pl_w_title)
        
    }
    
}else{
    message("do_iqw_tpm_plot is FALSE")
}


```



## Sequence logos of cluster architectures {#arch-seqlogos}

<!-- Sequence logos of clusters ordered by their median interquantile width (ascending order). -->

```{r seqlogos, collapse=TRUE}

#fig.width=11, fig.height=10, out.width="1200px", out.height="800px",

##
# suffix_label <- c("X", "Y", "Z")
# names(suffix_label) <- sample_names
if(do_plot_arch){
    for(sn in sample_names){
        
        result_dir_path <- file.path(archR_org_results_path, paste0(sn, "_results"))
        stopifnot(check_and_create_dir(result_dir_path))
        ##
        message("Generating architectures for clusters of sequences...")
        fname <- file.path(result_dir_path, paste0("Architectures_0-max.pdf"))
        iter5_dm_arch_list <- lapply(seq_along(perSample_archR_clusts[[sn]]), 
        function(y){
          x <- perSample_archR_clusts[[sn]][[y]]
          pl <- archR::plot_ggseqlogo_of_seqs(
            as.character(dm_2017_result[[sn]]$rawSeqs[x]), 
            pos_lab = -45:45, bits_yax = "auto", title = NULL)
          pl <- pl + theme_classic() + 
                     theme(axis.text = element_text(size=30),
                     axis.text.x = element_text(angle=0, vjust = 0.5, hjust = 0.5),
                     axis.text.y = element_text(hjust = -5),
                     # axis.text.y.left = element_text(hjust = -5), 
                     # axis.text.y.left = element_text(vjust = 0.5, hjust = 1.5), 
                     axis.title.y = element_text(size=30),# axis.line.y.right = element_blank(),
                     axis.title.y.left = element_text(margin = unit(c(0, 1, 0, 3), "cm")),
                     axis.title.y.right = element_text(margin = unit(c(0, 0, 0, 3), "cm")),
                     axis.ticks.length.y.left = unit(0.5, "cm"),
                     axis.ticks.length.y.right = unit(0.00, "cm"),
                     axis.ticks.length.x.bottom = unit(0.5, "cm"),
                     axis.ticks = element_line(size=1),
                     # plot.margin = unit(c(0,0,0,0), "cm")
                     plot.margin = unit(c(0,0.1,0,0.4), "cm")
                     ) +
            ggplot2::scale_y_continuous(breaks = seq(0, 2, by = 0.5),
                                        sec.axis = dup_axis(name = paste0("C",y, suffix_label[sn]),
                                                            labels = NULL))
            if(y == 1){
                pl <- pl + theme(plot.margin = unit(c(3,0.1,0,0.4), "cm"))
            }else{
                pl <- pl + theme(plot.margin = unit(c(3,0.1,0,0.4), "cm"))
            }
          pl
          
        })
        
        
        r1c1 <- cowplot::plot_grid(plotlist = iter5_dm_arch_list, ncol = 1, 
                                   nrow = length(perSample_archR_clusts[[sn]]))
        cowplot::save_plot(fname, plot = r1c1, limitsize = FALSE,
                           base_height = 5, base_width = 45,
                           ncol = 1,
                           nrow = length(perSample_archR_clusts[[sn]]),
                           dpi = 600)
        # cowplot::ggsave2(fname, plot= r1c1, width=85, height=105, units="cm",
        #       dpi = 600, limitsize = FALSE)
        
        # ## save PNGs
        # for(p in 1:length(iter5_dm_arch_list)){
        #     this_result_dir_path <- file.path(result_dir_path, "arch_png")
        #     stopifnot(check_and_create_dir(this_result_dir_path))
        #     fname <- file.path(this_result_dir_path, 
        #             paste0("Architecture_clust", p, "_0-max.png"))
        #     cowplot::ggsave2(fname, plot= iter5_dm_arch_list[[p]], 
        #       width=15, height=3, units="cm", dpi = 300)
        # }
        
        perSample_arch_combined[[sn]] <- r1c1
        perSample_arch[[sn]] <- iter5_dm_arch_list
        
        if(file.exists(fname)){
            knitr::include_graphics(fname)
        }
    }
}else{
    message("do_plot_arch is FALSE")
}
##


```


## Any dual initiation promoters in YC architecture

```{r check-dual-initiation-promoters}

## list of dual initiation promoters in human and drosophila are avilable from Nepal et al. 2020

dual_ini_prom <- read.csv(file.path(data_path_on_disk, "dual-initiation-promoters", "dual-initiation-promoters-human-drosophila.csv"), 
                          header = FALSE, skip = 4, sep = ",", 
                          col.names = c("human.gene.name", 
                                        "human.initiation.type",
                                        "human.YRorYCdominant", 
                                        "NA", 
                                        "drosophila.gene.name", 
                                        "drosophila.initiation.type",
                                        "drosophila.YRorYCdominant")
                          )
                          
dual_ini_prom_human <- dual_ini_prom[,c(1:3)]
dual_ini_prom_drosophila <- dual_ini_prom[,c(5:7)]

dual_ini_prom_drosophila$refseq.drosophila.gene.id <- 
    unlist(lapply(dual_ini_prom_drosophila$drosophila.gene.name, 
           function(x){
               strsplit(x, split = "|", fixed = TRUE)[[1]][1]
               }
           ))

dual_ini_prom_drosophila$drosophila.gene.name <- 
    unlist(lapply(dual_ini_prom_drosophila$drosophila.gene.name, 
           function(x){
               strsplit(x, split = "|", fixed = TRUE)[[1]][2]
               }
           ))

dual_ini_prom_drosophila <- dual_ini_prom_drosophila[which(!is.na(dual_ini_prom_drosophila$drosophila.gene.name)),]


## Cluster of interest in 6-8 hr clusters is cluster 13 with 416 sequences

# clust_gene_symbols <- as.data.frame(perSample_peakAnno[[2]])[perSample_archR_clusts[[2]][[use_cl]],]$SYMBOL
# 
# clust_dual_ini_prom <- intersect( dual_ini_prom_drosophila$drosophila.gene.name, clust_gene_symbols)
# 
# dom <- unlist(lapply(clust_dual_ini_prom, function(x){
#     idx <- which(dual_ini_prom_drosophila$drosophila.gene.name == x)
#     # stopifnot(length(idx) == 1)
#     dual_ini_prom_drosophila[idx,]$YRorYCdominant.1
# }))

# use_cl <- 9
# clust_gene_symbols <- as.data.frame(perSample_peakAnno[[2]])[perSample_archR_clusts[[2]][[use_cl]],]$SYMBOL
# 
# clust_dual_ini_prom <- intersect( dual_ini_prom_drosophila$drosophila.gene.name, clust_gene_symbols)
# 
# dom <- unlist(lapply(clust_dual_ini_prom, function(x){
#     idx <- which(dual_ini_prom_drosophila$drosophila.gene.name == x)
#     # stopifnot(length(idx) == 1)
#     dual_ini_prom_drosophila[idx,]$drosophila.YRorYCdominant
# }))

perSample_dual_ini_prom_overlaps <- vector("list", length(sample_names))
names(perSample_dual_ini_prom_overlaps) <- sample_names
dual_ini_bar_pl <- vector("list", length(sample_names))
names(dual_ini_bar_pl) <- sample_names

for(sn in sample_names){
    result_dir_path <-file.path(archR_org_results_path, 
                                paste0(sn, "_results"))
    
    peakAnno_df <- as.data.frame(perSample_peakAnno[[sn]])

    perSample_dual_ini_prom_overlaps[[sn]] <- 
        data.frame(clust_ID = samarth_df[[sn]]$clust_ID,
                   gene.names = peakAnno_df$SYMBOL,
                   Initiation_type = rep("NonDual", nrow(samarth_df[[sn]])),
                   YRorYCdominant = rep(NA, nrow(samarth_df[[sn]]))
                   )

    clust_levels <- levels(as.factor(samarth_df[[sn]]$clust_ID))
    for(l in seq_along(clust_levels)){
        which_idx <- which(samarth_df[[sn]]$clust_ID == clust_levels[l])
        perSample_dual_ini_prom_overlaps[[sn]]$clust_ID[which_idx] <- l
    }
    
    for(cl in perSample_archR_clusts[[sn]]){
        clust_gene_symbols <- peakAnno_df[cl,]$SYMBOL
        
        clust_dual_ini_prom <- intersect(dual_ini_prom_drosophila$drosophila.gene.name, clust_gene_symbols)
        
        iniTypeIdx <- unlist(lapply(clust_dual_ini_prom, function(x){
                    which_idx <- 
                        which(perSample_dual_ini_prom_overlaps[[sn]][cl,]$gene.names == x)
                    which_idx
                }))
    
        domType <- unlist(lapply(
            perSample_dual_ini_prom_overlaps[[sn]][cl,]$gene.names[iniTypeIdx], function(x){
            idx <- which(dual_ini_prom_drosophila$drosophila.gene.name == x)
            idx <- idx[1]
            # stopifnot(length(idx) == 1)
            dual_ini_prom_drosophila[idx,]$drosophila.YRorYCdominant
        }))
        
        perSample_dual_ini_prom_overlaps[[sn]][cl,]$Initiation_type[iniTypeIdx] <-
            "DualInitiation"
        perSample_dual_ini_prom_overlaps[[sn]][cl,]$YRorYCdominant[iniTypeIdx] <-
            domType
    }

    clust_labs <- unlist(lapply(seq_along(perSample_archR_clusts[[sn]]),
          function(x){
            paste0(x, "_(n=", length(perSample_archR_clusts[[sn]][[x]]), ")")
            }))
    
        dual_ini_bar_pl[[sn]] <- ggplot(perSample_dual_ini_prom_overlaps[[sn]], 
              aes(y = fct_rev(reorder(clust_ID, as.numeric(clust_ID))), 
                  fill = YRorYCdominant)) + 
          geom_bar(position = position_fill(reverse=TRUE), width = 0.6) + 
          # geom_text(aes(x = 1.05, y = clust_ID, label = clust_ID
          # )) + 
          ggplot2::theme_bw() + 
          # ggplot2::scale_fill_discrete(name = "", 
          #                              labels = use_labs[[sn]]) +
          ggplot2::scale_x_continuous("Proportion", limits = c(0,1)) +
          ggplot2::scale_y_discrete("", position = "left",
                            labels =  rev(clust_labs)) +
          ggeasy::easy_legend_at("bottom") + 
          ggeasy::easy_all_text_size(size=14)
        
    panel_pl <- cowplot::plot_grid(perSample_arch_combined[[sn]],
                                            dual_ini_bar_pl[[sn]],
                                    ncol = 2, 
                                    rel_widths = c(1.2,1),
                                    rel_heights = c(1,1),
                                    axis = "tb",
                                    align = "h"
                                    )

cowplot::save_plot(filename = file.path(result_dir_path, 
                            paste0("dual_initiation", sn, ".pdf")),
            plot = panel_pl, ncol = 3, nrow = 10,
            base_height = 2, base_width = 7, limitsize=FALSE)
# print(panel_pl)
cowplot::save_plot(filename = file.path(result_dir_path, 
                            paste0("dual_initiation", sn, ".png")),
            plot = panel_pl, ncol = 3, #nrow = 10,
            base_height = 13, base_width = 7, limitsize=FALSE)
}





```



```{r get-overlaps}
overlapTypeInfo <- vector("list", length(sample_names))
names(overlapTypeInfo) <- sample_names


iter_sample_names <- c(1,2,3,1,2)

for(s in seq_along(sample_names)){
  this_clusters <- perSample_archR_clusts[[sample_names[s]]]
  overlapTypeInfo[[s]] <- data.frame(
        clust = rep("0", length(unlist(this_clusters))),  
        Type = rep("N", length(unlist(this_clusters)))
          )
  perCluster_overlaps <- vector("list", length(this_clusters))
  for(l in seq_along(this_clusters)){
      sam <- this_clusters[[l]]
      overlapTypeInfo[[s]][sam, "clust"] <- l
      ## overlapping with next sample/s/s+1
      Atemp <- IRanges::overlapsAny(
        query = GenomicRanges::promoters(
            perSample_CAGEobj[[ sample_names[[iter_sample_names[s]]] ]][sam],
            upstream = 45, downstream = 45),
        subject = GenomicRanges::promoters(
            perSample_CAGEobj[[ sample_names[[iter_sample_names[s+1] ]] ]],
            upstream = 45, downstream = 45))
      A <- which(Atemp == TRUE)
      Anb <- length(A)
      # print(A)
      # print(Anb)
      useIdx <- this_clusters[[l]][A]
      overlapTypeInfo[[s]][useIdx, "Type"] <- "1-2"
      
      ## overlapping with next to next sample/s/s+2
      Btemp <- IRanges::overlapsAny(
        query = GenomicRanges::promoters(
            perSample_CAGEobj[[ sample_names[[iter_sample_names[s]]] ]][sam],
            upstream = 45, downstream = 45),
        subject = GenomicRanges::promoters(
            perSample_CAGEobj[[ sample_names[[iter_sample_names[s+2] ]] ]],
            upstream = 45, downstream = 45))
      ##
      B <- which(Btemp == TRUE)
      Bnb <- length(B)
      # print(B)
      # print(Bnb)
      useIdx <- this_clusters[[l]][B]
      overlapTypeInfo[[s]][useIdx, "Type"] <- "1-3"
      
      ## unique to self
      nonA <- which(Atemp == FALSE)
      nonB <- which(Btemp == FALSE)
      C <- intersect(nonA, nonB)
      Cnb <- length(C)
      # print(C)
      # print(Cnb)
      useIdx <- this_clusters[[l]][C]
      overlapTypeInfo[[s]][useIdx, "Type"] <- "1"
      
      ## Common all
      inAll <- intersect(A,B)
      Dnb <- length(inAll)
      # print(inAll)
      # print(Dnb)
      useIdx <- this_clusters[[l]][inAll]
      overlapTypeInfo[[s]][useIdx, "Type"] <- "1-2-3"
      
      ##
      # message(paste(length(sam), Anb, Bnb, Cnb, Dnb, sum(Anb,Bnb,Cnb,Dnb), collapse=", "))
      # print(Bnb)
      # print(Cnb)
      perCluster_overlaps[[l]] <- c(Anb, Bnb, Cnb, Dnb)
  }
  perCluster_overlaps_perSample[[sample_names[s]]] <- do.call(rbind, perCluster_overlaps)
}

```



<br/>
<br/><br/><br/><br/><br/><br/><br/><br/><br/><br/>
<br/><br/><br/><br/><br/><br/><br/><br/><br/><br/>


## Per sample list of ENTREZ IDs per cluster

```{r per-sample-entrezIDs-per-cluster}

perSample_entrezList <- lapply(seq_along(perSample_archR_clusts), function(x){
            as_df_entrez_id <- as.data.frame(perSample_peakAnno[[x]])$ENTREZID
            sam <- lapply(perSample_archR_clusts[[x]], function(y){
              temp <- as_df_entrez_id[y]
              temp[which(!is.na(temp))]
            })
            names(sam) <- paste0("C", seq_along(sam))
            sam
        })
names(perSample_entrezList) <- names(perSample_archR_clusts)

```


## Per cluster gene names -- RAL28 2-4h

```{r get-per-cluster-gene-names1}


sn <- sample_names[1]
result_dir_path <- file.path(archR_org_results_path, paste0(sn, "_results"))

peakAnno_df <- as.data.frame(perSample_peakAnno[[sn]])
## peakAnno_df here doesn't have columns tpm.dominant_ctss
peakAnno_df$tpm.dominant_ctss <- dm_schor2017_bed_info[[sn]]$domTPM

unique_genes <- unique(peakAnno_df$SYMBOL)
sumTPM_across_TC_per_gene <- lapply(unique_genes, function(x){
    sum(peakAnno_df$tpm.dominant_ctss[which(peakAnno_df$SYMBOL == x)])
})
names(sumTPM_across_TC_per_gene) <- unique_genes 

perSample_genes1 <- vector("list", length(sample_names))
names(perSample_genes1) <- sample_names

genes1 <- lapply(seq_along(perSample_archR_clusts[[sn]]), 
function(x){
    ##
    all_genenames <-
      peakAnno_df[unlist(perSample_archR_clusts[[sn]][x]), c("GENENAME", "ENTREZID", "geneId", "SYMBOL", "annotation", "width", "tpm.dominant_ctss")]
    
    ## To sort by motif scores, get motif scores first
    motif_scores <- suppressMessages(get_motif_scores(dm_2017_result,
                                      perSample_archR_clusts, sn, clust_id = x))
    ##
    ##
    anno_terms1 <- all_genenames$annotation
    anno_terms_splits <- strsplit(anno_terms1, " ")
    anno_terms <- unlist(lapply(anno_terms_splits, function(x){
                        if(is.na(x[1])){ "NA";
                        }else if(grepl("Intron", x[1]) || grepl("Exon", x[1])){
                            paste0(x[1], " (", paste(x[3:6], collapse = " "))
                        }else if(grepl("Promoter", x[1])){
                            x[1]
                        }else{ paste(x[1], x[2]) }
                    }))
    ##
    sorted <- sort(motif_scores, index.return=TRUE,
                    decreasing = TRUE)
    ## What if we leave unsorted here? The display table will enable sorting anyway
    
    sorted <- list(x = seq(length(motif_scores)), ix = seq(length(motif_scores)))
    ##
    ## To sort alphabetically by Gene Symbol
    naStr <- unlist(lapply(all_genenames$SYMBOL, function(x){
          if(is.na(x)){
              "NA"
          }else{
              x
          }
        }))
    all_genenames$SYMBOL <- naStr
    
    sam2 <- unlist(lapply(all_genenames$SYMBOL, function(x) {
      if(x != "NA"){
        sumTPM_across_TC_per_gene[[x]]
      }else{
        NA
      }
    }))
    
    ##
    # Displays as datatable which is sortable, searchable
    print_df <- data.frame("Symbol" = all_genenames$SYMBOL[sorted$ix],
                     "Weblink" = 
        paste0('<a href="https://flybase.org/reports/', 
            all_genenames$geneId[sorted$ix], '" target="_blank">',
            all_genenames$GENENAME[sorted$ix], 
      '</a> '),
        "Annot" = anno_terms[sorted$ix],
        "domTPM" = format(round(all_genenames$tpm.dominant_ctss[sorted$ix], 3), nsmall=3),
        "%%.domTPM" = format(round(100*(all_genenames$tpm.dominant_ctss[sorted$ix]/sam2[sorted$ix]), 2), nsmall=2),
        "Match.score"= form_str(motif_scores[sorted$ix])
        )
    colnames(print_df)[5] <- "%domTPM"
    return(print_df)
    
})
perSample_genes1[[sn]] <- genes1




```


## Per cluster gene names -- RAL28 6-8h

```{r get-per-cluster-gene-names2}


sn <- sample_names[2]
result_dir_path <- file.path(archR_org_results_path, paste0(sn, "_results"))

peakAnno_df <- as.data.frame(perSample_peakAnno[[sn]])
## peakAnno_df here doesn't have columns tpm.dominant_ctss
peakAnno_df$tpm.dominant_ctss <- dm_schor2017_bed_info[[sn]]$domTPM

unique_genes <- unique(peakAnno_df$SYMBOL)
sumTPM_across_TC_per_gene <- lapply(unique_genes, function(x){
    sum(peakAnno_df$tpm.dominant_ctss[which(peakAnno_df$SYMBOL == x)])
})
names(sumTPM_across_TC_per_gene) <- unique_genes 


genes1 <- lapply(seq_along(perSample_archR_clusts[[sn]]), 
function(x){
    ##
    all_genenames <-
      peakAnno_df[unlist(perSample_archR_clusts[[sn]][x]), c("GENENAME", "ENTREZID", "geneId", "SYMBOL", "annotation", "width", "tpm.dominant_ctss")]
    
    ## To sort by motif scores, get motif scores first
    motif_scores <- suppressMessages(get_motif_scores(dm_2017_result,
                                      perSample_archR_clusts, sn, clust_id = x))
    ##
    ##
    anno_terms1 <- all_genenames$annotation
    anno_terms_splits <- strsplit(anno_terms1, " ")
    anno_terms <- unlist(lapply(anno_terms_splits, function(x){
                        if(is.na(x[1])){ "NA";
                        }else if(grepl("Intron", x[1]) || grepl("Exon", x[1])){
                            paste0(x[1], " (", paste(x[3:6], collapse = " "))
                        }else if(grepl("Promoter", x[1])){
                            x[1]
                        }else{ paste(x[1], x[2]) }
                    }))
    ##
    sorted <- sort(motif_scores, index.return=TRUE,
                    decreasing = TRUE)
    ## What if we leave unsorted here? The display table will enable sorting anyway
    
    sorted <- list(x = seq(length(motif_scores)), ix = seq(length(motif_scores)))
    ##
    ## To sort alphabetically by Gene Symbol
    naStr <- unlist(lapply(all_genenames$SYMBOL, function(x){
          if(is.na(x)){
              "NA"
          }else{
              x
          }
        }))
    all_genenames$SYMBOL <- naStr
    
    sam2 <- unlist(lapply(all_genenames$SYMBOL, function(x) {
      if(x != "NA"){
        sumTPM_across_TC_per_gene[[x]]
      }else{
        NA
      }
    }))
    
    ##
    # Displays as datatable which is sortable, searchable
    print_df <- data.frame("Symbol" = all_genenames$SYMBOL[sorted$ix],
                     "Weblink" = 
        paste0('<a href="https://flybase.org/reports/', 
            all_genenames$geneId[sorted$ix], '" target="_blank">',
            all_genenames$GENENAME[sorted$ix], 
      '</a> '),
        "Annot" = anno_terms[sorted$ix],
        "domTPM" = format(round(all_genenames$tpm.dominant_ctss[sorted$ix], 3), nsmall=3),
        "%%.domTPM" = format(round(100*(all_genenames$tpm.dominant_ctss[sorted$ix]/sam2[sorted$ix]), 2), nsmall=2),
        "Match.score"= form_str(motif_scores[sorted$ix])
        )
    colnames(print_df)[5] <- "%domTPM"
    return(print_df)
    
})
perSample_genes1[[sn]] <- genes1


```


## Per cluster gene names -- RAL28 10-12h

```{r get-per-cluster-gene-names3}


sn <- sample_names[3]
result_dir_path <- file.path(archR_org_results_path, paste0(sn, "_results"))

peakAnno_df <- as.data.frame(perSample_peakAnno[[sn]])
## peakAnno_df here doesn't have columns tpm.dominant_ctss
peakAnno_df$tpm.dominant_ctss <- dm_schor2017_bed_info[[sn]]$domTPM

unique_genes <- unique(peakAnno_df$SYMBOL)
sumTPM_across_TC_per_gene <- lapply(unique_genes, function(x){
    sum(peakAnno_df$tpm.dominant_ctss[which(peakAnno_df$SYMBOL == x)])
})
names(sumTPM_across_TC_per_gene) <- unique_genes 

genes1 <- lapply(seq_along(perSample_archR_clusts[[sn]]), 
function(x){
    ##
    all_genenames <-
      peakAnno_df[unlist(perSample_archR_clusts[[sn]][x]), c("GENENAME", "ENTREZID", "geneId", "SYMBOL", "annotation", "width", "tpm.dominant_ctss")]
    
    ## To sort by motif scores, get motif scores first
    motif_scores <- suppressMessages(get_motif_scores(dm_2017_result,
                                      perSample_archR_clusts, sn, clust_id = x))
    ##
    ##
    anno_terms1 <- all_genenames$annotation
    anno_terms_splits <- strsplit(anno_terms1, " ")
    anno_terms <- unlist(lapply(anno_terms_splits, function(x){
                        if(is.na(x[1])){ "NA";
                        }else if(grepl("Intron", x[1]) || grepl("Exon", x[1])){
                            paste0(x[1], " (", paste(x[3:6], collapse = " "))
                        }else if(grepl("Promoter", x[1])){
                            x[1]
                        }else{ paste(x[1], x[2]) }
                    }))
    ##
    sorted <- sort(motif_scores, index.return=TRUE,
                    decreasing = TRUE)
    ## What if we leave unsorted here? The display table will enable sorting anyway
    
    sorted <- list(x = seq(length(motif_scores)), ix = seq(length(motif_scores)))
    ##
    ## To sort alphabetically by Gene Symbol
    naStr <- unlist(lapply(all_genenames$SYMBOL, function(x){
          if(is.na(x)){
              "NA"
          }else{
              x
          }
        }))
    all_genenames$SYMBOL <- naStr
    
    sam2 <- unlist(lapply(all_genenames$SYMBOL, function(x) {
      if(x != "NA"){
        sumTPM_across_TC_per_gene[[x]]
      }else{
        NA
      }
    }))
    
    ##
    # Displays as datatable which is sortable, searchable
    print_df <- data.frame("Symbol" = all_genenames$SYMBOL[sorted$ix],
                     "Weblink" = 
        paste0('<a href="https://flybase.org/reports/', 
            all_genenames$geneId[sorted$ix], '" target="_blank">',
            all_genenames$GENENAME[sorted$ix], 
      '</a> '),
        "Annot" = anno_terms[sorted$ix],
        "domTPM" = format(round(all_genenames$tpm.dominant_ctss[sorted$ix], 3), nsmall=3),
        "%%.domTPM" = format(round(100*(all_genenames$tpm.dominant_ctss[sorted$ix]/sam2[sorted$ix]), 2), nsmall=2),
        "Match.score"= form_str(motif_scores[sorted$ix])
        )
    colnames(print_df)[5] <- "%domTPM"
    return(print_df)
    
})
perSample_genes1[[sn]] <- genes1


```

## Investigating particular His2B clusters in all three samples

Specifically, in all three samples, a particular cluster enriched in His2B genes is identified. 
This cluster, unlike other histone gene clusters, is corrupted with many non-histone genes' tag clusters.
Thus, there were a few questions raised:

1. what are these other genes?
These gene names/symbols are provided in the table.

2. why do all gene symbols read the same when the FlyBase gene IDs are different?
While the FlyBase gene IDs are different, they all have the same ENTREZIDs (many:1 mapping), and ChIPseeker (the package we use for annotation) keeps/uses only the first one in this scenario.


3. how does the alignment of core promoter sequences of these tag clusters look?
Their alignments can be visualized in the web browser itself using the R package DECIPHER.
```{r investigate-his2-clusters}


pick_clust_idx <- c(4,6,5) ## the relevant cluster in each sample
use_widths <- c(1400, 1400, 1500) 
# third sample requires more space to accommodate the longer sample name

dummy <- lapply(seq_along(pick_clust_idx), function(x){
    message("X = ", x)
    sn <- sample_names[x]
    seqs <- dm_2017_result[[ sn ]]$rawSeqs[
        perSample_archR_clusts[[ sn ]][[ pick_clust_idx[x] ]]
        ]
    
    old_names <- names(seqs)
    old_names_pre <- strsplit(old_names, split = ";up")
    old_names_pre2 <- unlist(lapply(old_names_pre, function(x) x[[1]]))
    
    names(seqs) <- paste0(
        sn, "__",
        perSample_genes1[[ sn ]][[ pick_clust_idx[x] ]]$Symbol, "__", 
        perSample_genes1[[ sn ]][[ pick_clust_idx[x] ]]$Match.score, "__",
        old_names_pre2)
    
    use_path <- file.path(archR_org_results_path, 
                                paste0(sn, "_results"))
    use_fname <- file.path(use_path, 
        paste0("His2B_cluster_DNA_sequences_Sample_", 
        sn, "_clust", pick_clust_idx[x], ".html"))
        
    
    sort_ord <- sort(as.double(perSample_genes1[[ sample_names[x] ]][[ pick_clust_idx[x] ]]$Match.score), index.return = TRUE, decreasing = TRUE)
    seqs <- seqs[sort_ord$ix]
    
    fhtml <- DECIPHER::BrowseSeqs(htmlFile = use_fname, 
                                    myXStringSet = seqs, 
                                    openURL = FALSE)
    
    print(fhtml)
    message("Getting screenshots of pages...")
    webshot2::webshot(url = fhtml, file = paste0(fhtml, "_screenshot.png"), 
        vwidth = use_widths[x], vheight = 600)
    message("...done")
    ######
    ## Further clustering them using seqArchR
    # foo_seqs <-  dm_2017_result[[ sn ]]$rawSeqs[
    #     perSample_archR_clusts[[ sn ]][[ pick_clust_idx[x] ]]
    #     ]
    # foo_mat <- seqArchR::get_one_hot_encoded_seqs(foo_seqs, sinuc_or_dinuc = "dinuc")
    # 
    # for(v in c(4,5)){
    #     foo_config <- seqArchR::set_config(chunk_size = length(foo_seqs), bound = 10^-v, 
    #         parallelize = TRUE, n_cores = 4, 
    #         flags = list(debug = TRUE, time = TRUE, plot = TRUE, verbose = TRUE))
    #     
    #     his2b_result <- seqArchR::seqArchR(config = foo_config, seqs_ohe_mat = foo_mat, 
    #         seqs_raw = foo_seqs, total_itr = 3, seqs_pos = -45:45, 
    #         set_ocollation = c(FALSE,FALSE,FALSE), 
    #         o_dir = file.path(use_path, 
    #             paste0("His2B_clusters_further_analysis_bound_", 10^-v)))
    # }
    ## 
    ## 
    
})




```

Re-processing just these clusters further with seqArchR (to confirm) shows that, while the given sequences are further clustered, seqArchR identifies them as overfitted, and reassigns them to the base cluster. As a result no further clusters appear in the end although they have been identified.

This is an important point to be noted in the discussion section of the paper as perhaps a limitation of the current version.



## Figures for the paper {#paper-figures}

Some figures are reproduced with special sizes of text etc to suit its 
inclusion in the paper at high resolution.

### For paper: IQW-TPM-PhastCons plots for paper {#paper-iqw-tpm-plots}



```{r paper-iqw-tpm-plots, warning=FALSE, message=FALSE}

suffix_label <- c("X", "Y", "Z")
names(suffix_label) <- sample_names
use_txt_size <- 100
####
if(do_IQW_TPM_plots){
    message("Task: Producing IQW_TPM_PhastCons scores combined plot")
    for(sn in sample_names){
        result_dir_path <- file.path(archR_org_results_path, 
                                paste0(sn, "_results"))
        stopifnot(check_and_create_dir(result_dir_path))
        pl_iqw <- get_iqw_ord_plot(iqw = TRUE, y_axis_text = TRUE, 
                                   use_notch = FALSE, text_size = use_txt_size,
                                samarth_df = samarth_df[[sn]], 
                                seqs_clust = perSample_archR_clusts[[sn]], 
                                use_suffix = suffix_label[sn])
        ##
        pl_tpm <- get_iqw_ord_plot(tpm = TRUE, y_axis_text = FALSE,
                                   use_notch = FALSE, text_size = use_txt_size,
                    samarth_df = samarth_df[[sn]], 
                    seqs_clust = perSample_archR_clusts[[sn]], 
                    use_suffix = suffix_label[sn])
        ##
        pl_phast <- get_iqw_ord_plot(phast = TRUE, y_axis_text = FALSE, 
                                     use_notch = FALSE, text_size = use_txt_size,
                    samarth_df = samarth_df[[sn]], 
                    seqs_clust = perSample_archR_clusts[[sn]], 
                    use_suffix = suffix_label[sn])
        ## IQW ordered plots
        iqw_tpm_ord_pls <- pl_iqw | pl_tpm
        
        iqw_tpm_phast_ord_pls <- pl_iqw + pl_tpm + pl_phast 

        
        perSample_pl[[sn]] <- iqw_tpm_phast_ord_pls
        
        title_str <- paste0("Sample_", sn, "_IQW_TPM_phast_plot")
        pl_w_title <- iqw_tpm_phast_ord_pls + plot_annotation(title = title_str)
        cowplot::save_plot(filename = file.path(result_dir_path,
                paste0(title_str, "_paper.pdf")),
                plot = pl_w_title, 
                base_height = 30, base_width = 35
                )
    }
    
}else{
    message("do_iqw_tpm_plot is FALSE")
}


```


### For paper: Sequence logos of cluster architectures {#paper-arch-seqlogos}

<!-- Sequence logos of clusters ordered by their median interquantile width (ascending order). -->

```{r paper-seqlogos, collapse=TRUE}

#fig.width=11, fig.height=10, out.width="1200px", out.height="800px",

##
# suffix_label <- c("X", "Y", "Z")
# names(suffix_label) <- sample_names
if(do_plot_arch){
    for(sn in sample_names){
        
        result_dir_path <- file.path(archR_org_results_path, paste0(sn, "_results"))
        stopifnot(check_and_create_dir(result_dir_path))
        ##
        message("Generating architectures for clusters of sequences...")
        fname <- file.path(result_dir_path, paste0("Architectures_0-max_paper.pdf"))
        iter5_dm_arch_list <- lapply(seq_along(perSample_archR_clusts[[sn]]), 
        function(y){
          x <- perSample_archR_clusts[[sn]][[y]]
          pl <- archR::plot_ggseqlogo_of_seqs(
            as.character(dm_2017_result[[sn]]$rawSeqs[x]), 
            pos_lab = -45:45, bits_yax = "auto", title = NULL)
          pl <- pl + theme_classic() + 
                     theme(axis.text = element_text(size=use_txt_size),
                     axis.text.x = element_text(angle=0, vjust = 0.5, hjust = 0.5),
                     axis.text.y = element_text(hjust = -5),
                     # axis.text.y.left = element_text(hjust = -5), 
                     # axis.text.y.left = element_text(vjust = 0.5, hjust = 1.5), 
                     axis.title.y = element_text(size=use_txt_size),# axis.line.y.right = element_blank(),
                     axis.title.y.left = element_text(margin = unit(c(0, 1, 0, 3), "cm")),
                     axis.title.y.right = element_text(margin = unit(c(0, 0, 0, 3), "cm")),
                     axis.ticks.length.y.left = unit(0.5, "cm"),
                     axis.ticks.length.y.right = unit(0.00, "cm"),
                     axis.ticks.length.x.bottom = unit(1, "cm"),
                     axis.ticks = element_line(size=1),
                     # plot.margin = unit(c(0,0,0,0), "cm")
                     plot.margin = unit(c(0,0.1,0,0.4), "cm")
                     ) +
            ggplot2::scale_y_continuous(breaks = seq(0, 2, by = 0.5),
                                        sec.axis = dup_axis(name = paste0("C",y, suffix_label[sn]),
                                                            labels = NULL))
            if(y == 1){
                pl <- pl + theme(plot.margin = unit(c(3,0.1,0,0.4), "cm"))
            }else{
                pl <- pl + theme(plot.margin = unit(c(3,0.1,0,0.4), "cm"))
            }
          pl
          # pl <- pl + theme_classic()
        })
        # print(length(iter5_dm_arch_list))
        
        r1c1 <- cowplot::plot_grid(plotlist = iter5_dm_arch_list, ncol = 1, 
                                   nrow = length(perSample_archR_clusts[[sn]]))
        cowplot::save_plot(fname, plot = r1c1, limitsize = FALSE,
                           base_height = 5, base_width = 45,
                           ncol = 1,
                           nrow = length(perSample_archR_clusts[[sn]]),
                           dpi = 600)
        # cowplot::ggsave2(fname, plot= r1c1, width=85, height=105, units="cm",
        #       dpi = 600, limitsize = FALSE)
        
        # ## save PNGs
        # for(p in 1:length(iter5_dm_arch_list)){
        #     this_result_dir_path <- file.path(result_dir_path, "arch_png")
        #     stopifnot(check_and_create_dir(this_result_dir_path))
        #     fname <- file.path(this_result_dir_path, 
        #             paste0("Architecture_clust", p, "_0-max.png"))
        #     cowplot::ggsave2(fname, plot= iter5_dm_arch_list[[p]], 
        #       width=15, height=3, units="cm", dpi = 300)
        # }
        r1c1
        perSample_arch_combined[[sn]] <- r1c1
        perSample_arch[[sn]] <- iter5_dm_arch_list
        
        if(file.exists(fname)){
            knitr::include_graphics(fname)
        }
    }
}else{
    message("do_plot_arch is FALSE")
}
##


```


### For paper: All of it together

```{r paper-all-together}

# This piece of code is reproduced from the combined panel section above to 
# focus and reflect on details relevant to the main paper text

panel_pl <- vector("list", length(sample_names)) 
names(panel_pl) <- sample_names
use_labs <- list(c("2-4", "2-4 & 6-8", "All", "2-4 & 10-12"), 
             c("6-8", "6-8 & 10-12", "All", "2-4 & 6-8"),
             c("10-12", "2-4 & 10-12", "All", "6-8 & 10-12")
            )
names(use_labs) <- sample_names

## Rationale for choice of colors:
## In each plot, one color shows the proportion of TCs unique to that transition, 
## one color shows what is common to 2-4h and 6-8h, one showing prop of common TCs 
## between 6-8h and 10-12h, one showing prop of common between 2-4h and 10-12h.

## Choice of colors is made by taking into account which colors will appear 
## side-by-side
## 
# use_cols <- list("2-4" = ,
#                  "2-4 & 6-8" = ,   
#                  "All" = dar1[2],  
#                  "2-4 & 10-12"  = ,
#                  "6-8" = ,
#                  "6-8 & 10-12" = ,
#                  "10-12" = )
# names(use_cols) <- unique(as.vector(unlist(use_labs)))


zis1 <- wesanderson::wes_palette("Zissou1", n=4)
dar1 <- wesanderson::wes_palette("Darjeeling1", n=4)
dar2 <- wesanderson::wes_palette("Darjeeling2", n=4)
royal1 <- wesanderson::wes_palette("Royal1", n=4)

for(sn in sample_names){
    result_dir_path <- file.path(archR_org_results_path, paste0(sn, "_results"))
    stopifnot(check_and_create_dir(result_dir_path))
    
    clust_labs <- unlist(lapply(seq_along(perSample_archR_clusts[[sn]]),
      function(x){
        paste0(x, "_(n=", length(perSample_archR_clusts[[sn]][[x]]), ")")
        }))
     
    bar_pl <- ggplot(overlapTypeInfo[[sn]], 
      aes(y = fct_rev(reorder(clust, as.numeric(clust))), fill = Type)) + 
      geom_bar(position = position_fill(reverse=TRUE), width = 0.6) + 
      # ggplot2::theme_minimal() + 
      ggplot2::scale_fill_manual(name = "", 
                                   values = c(dar2[2], dar2[3], dar1[2], royal1[2]),
                                   labels = use_labs[[sn]]) +
      xlab("") +
      # ggplot2::scale_x_continuous("Proportion Overlap", limits = c(0,1)) +
      # ggplot2::scale_fill_brewer(palette = "Accent", direction = -1) + 
      # ggplot2::scale_fill_manual(values = c(royal1[2], royal1[1], zis1[3], zis1[2])) +
      # ggplot2::scale_y_discrete(expand = c(0, 0)) +
      ggplot2::theme_classic() + # bw() + 
      ggplot2::theme(panel.grid = element_blank(),
                     axis.ticks = element_line(size=1),
                     axis.text.y = element_blank(), 
                     axis.title.x = element_blank(),
                     axis.ticks.length.x.bottom = unit(1, "cm"),
                     axis.title.y = element_blank(), 
                     # axis.title.x.bottom = element_text(vjust = -0.5),
                     axis.text.x = element_text(colour = "black",
                                       size = use_txt_size, vjust =-0.25),
                     # axis.line.y.left = element_blank(),
                     plot.margin = margin(-0.5,0,0,0, unit = "pt"),
                     legend.text = element_text(colour = "black",
                                       size = use_txt_size), 
                     legend.position = "bottom", 
                     legend.key.size = unit(2.5, "cm"),
                     legend.margin = margin(t = 20, r = 1, b = 1, l = 1)
                     ) +
      ggplot2::guides(fill = guide_legend(nrow = 2, byrow = TRUE,
                                          title.position = "left",
                                          title = "Proportion Overlap"
                                          )) +
      # ggplot2::theme(panel.grid = element_blank(),
      #              ) + 
      # ggplot2::theme_void() + 
      # ggeasy::easy_legend_at("bottom") +
      ggeasy::easy_all_text_size(size=use_txt_size)
    
    # This aligning thing is required when only cowplot is used
    
    # aligned_pl <- cowplot::plot_grid((perSample_pl[[sn]]
    #                                     +
    #                                 ggeasy::easy_all_text_size(size=60)),
    #                                 NULL,
    #                                 (perSample_arch_combined[[sn]]
    #                                     +
    #                                 ggeasy::easy_all_text_size(size=60)),
    #                                 NULL,
    #                                 ncol = 4,
    #                                 axis = "b",
    #                                 align = "h",
    #                                 rel_widths = c(0.8, 0.03, 1, 0.03))
    
    panel_pl[[sn]] <- cowplot::plot_grid(
                                    (perSample_pl[[sn]]
                                        +
                                    ggeasy::easy_all_text_size(size=use_txt_size)),
                                    NULL,
                                    (perSample_arch_combined[[sn]]
                                        +
                                    ggeasy::easy_all_text_size(size=use_txt_size)),
                                    NULL,
                                    bar_pl,
                                    ncol = 5,
                                    rel_widths = c(0.8, 0.015, 1, 0.015, 0.3),
                                    rel_heights = c(1, 1, 1.8, 1, 1),
                                    axis = "tb",
                                    align = "hv"
                                    )
    
    
    # panel_pl[[sn]] <- panel_pl[[sn]] + 
    #   ggeasy::easy_all_text_size(size=16)

    cowplot::save_plot(filename = file.path(result_dir_path,
                                            paste0("drosophila_figure_paper_", sn,".pdf")),
                plot = panel_pl[[sn]], ncol = 3, nrow = 15,
                base_height = 10, base_width = 75, limitsize=FALSE, dpi=300)
    # cowplot::ggsave2(filename = file.path(result_dir_path,
    #                                         paste0("drosophila_figure_paper_", sn,".pdf")),
    #              plot = panel_pl[[sn]],
    #              device = "pdf", dpi = 600,
    #              width = 26, height = 13, units = "in", limitsize = FALSE
    #              )
    
}

# all_samples_together <- cowplot::plot_grid(plotlist = panel_pl,
#                                     ncol = 1, 
#                                     nrow = 3,
#                                     labels = c('A', 'B', 'C'), vjust=1, hjust = 0,
#                                     label_size = 24,
#                                     label_fontface = 'plain',
#                                     rel_widths = c(1,1,1),
#                                     rel_heights = c(1,1,1),
#                                     axis = "th",
#                                     align = "b"
#                                     )

# cowplot::save_plot(filename = file.path(result_dir_path, "drosophila_figure_paper.pdf"),
#                 plot = all_samples_together, 
#                 ncol = 1,
#                 nrow = 3,
#                 base_height = 12,
#                 base_width = 18,
#                 limitsize=FALSE,
#                 device = "pdf", dpi = 600 
#                 # width = 6, height = 10, units = "in"
#                 )

# cowplot::ggsave2(filename = file.path(result_dir_path, "drosophila_figure_paper.pdf"),
#                  plot = all_samples_together,
#                  device = "pdf", dpi = 300,
#                  width = 26, height = 40, units = "in", limitsize = FALSE
#                  )

```


### For paper: GO terms enrichments
```{r paper-go-terms}

## TTAGT architecture : 
## collect c9z, c10x and c12y clusters and compare their enriched go terms
arch_term <- "TTANT"
clust_list <- list(c(1,10), c(2,12), c(3,9))
go_res <- lapply(clust_list, function(x){
                clusterProfiler::enrichGO(perSample_entrezList[[x[1]]][[x[2]]],
                    OrgDb = org.Dm.eg.db, ont = "all", pool = TRUE, 
                    keyType = "ENTREZID", 
                    pvalueCutoff = 0.05, qvalueCutoff = 0.1)
    })
names(go_res) <- paste0("C", 
                        unlist(lapply(clust_list, function(x) x[2])), 
                c("X", "Y", "Z"))

compare_result <- clusterProfiler::merge_result(go_res)

go_term_fs <- 12
show_cats <- c(5, 10)
go_pl <- vector("list", length(show_cats))
for(i in seq_along(show_cats)){
    p1 <- dotplot(compare_result, showCategory = show_cats[i],
                          title = paste0("Comparing ", arch_term, " architectures"),
                          font.size = go_term_fs)
    pl <- p1 + DOSE::theme_dose(font.size = go_term_fs) +
            ggplot2::scale_y_discrete(labels = scales::label_wrap(50)) +
            ggplot2::scale_color_gradient() + 
            ggplot2::theme(title = element_text(size = go_term_fs),
                           legend.text = element_text(size = go_term_fs),
                           legend.title = element_text(size = go_term_fs))
    go_pl[[i]] <- pl
    cowplot::save_plot(
        filename = file.path(result_dir_path, paste0(arch_term, "_go_plot_top", show_cats[i], "_terms.pdf")), 
        plot = go_pl[[i]], 
        base_height = 10, base_width = 8)    
}
ttant_go_pl <- go_pl

##############
## pausing : 
## collect c9z, c10x and c12y clusters and compare their enriched go terms
arch_term <- "POLII_pausing"
clust_list <- list(c(1,15), c(2,14), c(3,15))
go_res <- lapply(clust_list, function(x){
                clusterProfiler::enrichGO(perSample_entrezList[[x[1]]][[x[2]]],
                    OrgDb = org.Dm.eg.db, ont = "all", pool = TRUE, 
                    keyType = "ENTREZID", 
                    pvalueCutoff = 0.05, qvalueCutoff = 0.1)
    })
names(go_res) <- paste0("C", 
                        unlist(lapply(clust_list, function(x) x[2])), 
                c("X", "Y", "Z"))

compare_result <- clusterProfiler::merge_result(go_res)

go_term_fs <- 12
show_cats <- c(5, 10)
go_pl <- vector("list", length(show_cats))
for(i in seq_along(show_cats)){
    p1 <- dotplot(compare_result, showCategory = show_cats[i],
                          title = paste0("Comparing ", arch_term, " architectures"),
                          font.size = go_term_fs)
    pl <- p1 + DOSE::theme_dose(font.size = go_term_fs) +
            ggplot2::scale_y_discrete(labels = scales::label_wrap(50)) +
            ggplot2::scale_color_gradient() + 
            ggplot2::theme(title = element_text(size = go_term_fs),
                           legend.text = element_text(size = go_term_fs),
                           legend.title = element_text(size = go_term_fs))
    go_pl[[i]] <- pl
    cowplot::save_plot(
        filename = file.path(result_dir_path, paste0(arch_term, "_go_plot_top", show_cats[i], "_terms.pdf")), 
        plot = go_pl[[i]], 
        base_height = 10, base_width = 8)    
}
pol2_pausing_go_pl <- go_pl



##############
## TCT architectures
arch_term <- "TCT"
clust_list <- list(c(1,7), c(2,11), c(3,10))
go_res <- lapply(clust_list, function(x){
                clusterProfiler::enrichGO(perSample_entrezList[[x[1]]][[x[2]]],
                    OrgDb = org.Dm.eg.db, ont = "all", pool = TRUE, 
                    keyType = "ENTREZID", 
                    pvalueCutoff = 0.05, qvalueCutoff = 0.1)
    })
names(go_res) <- paste0("C", 
                        unlist(lapply(clust_list, function(x) x[2])), 
                c("X", "Y", "Z"))

compare_result <- clusterProfiler::merge_result(go_res)

go_term_fs <- 12
show_cats <- c(5, 10)
go_pl <- vector("list", length(show_cats))
for(i in seq_along(show_cats)){
    p1 <- dotplot(compare_result, showCategory = show_cats[i],
                          title = paste0("Comparing ", arch_term, " architectures"),
                          font.size = go_term_fs)
    pl <- p1 + DOSE::theme_dose(font.size = go_term_fs) +
            ggplot2::scale_y_discrete(labels = scales::label_wrap(50)) +
            ggplot2::scale_color_gradient() + 
            ggplot2::theme(title = element_text(size = go_term_fs),
                           legend.text = element_text(size = go_term_fs),
                           legend.title = element_text(size = go_term_fs))
    go_pl[[i]] <- pl
    cowplot::save_plot(
        filename = file.path(result_dir_path, paste0(arch_term, "_go_plot_top", show_cats[i], "_terms.pdf")), 
        plot = go_pl[[i]], 
        base_height = 10, base_width = 8)    
}
tct_go_pl <- go_pl
############
## cAAA 
arch_term <- "cAAA"
go_term_fs <- 12
show_cats <- c(5, 10)
use_ht <- c(6, 10)
clust_list <- list(c(1,14), c(2,19), c(3,21))
go_res <- lapply(clust_list, function(x){
                clusterProfiler::enrichGO(perSample_entrezList[[x[1]]][[x[2]]],
                    OrgDb = org.Dm.eg.db, ont = "all", pool = TRUE, 
                    keyType = "ENTREZID", 
                    pvalueCutoff = 0.05, qvalueCutoff = 0.1)
    })
names(go_res) <- paste0("C", 
                        unlist(lapply(clust_list, function(x) x[2])), 
                c("X", "Y", "Z"))

compare_result <- clusterProfiler::merge_result(go_res)

# go_term_fs <- 12
# show_cats <- c(5, 10)
go_pl <- vector("list", length(show_cats))
for(i in seq_along(show_cats)){
    p1 <- dotplot(compare_result, showCategory = show_cats[i],
                          title = paste0("Comparing ", arch_term, " architectures"),
                          font.size = go_term_fs)
    pl <- p1 + DOSE::theme_dose(font.size = go_term_fs) +
            ggplot2::scale_y_discrete(labels = scales::label_wrap(50)) +
            ggplot2::scale_color_gradient() + 
            ggplot2::theme(title = element_text(size = go_term_fs),
                           legend.text = element_text(size = go_term_fs),
                           legend.title = element_text(size = go_term_fs))
    go_pl[[i]] <- pl
    cowplot::save_plot(
        filename = file.path(result_dir_path, paste0(arch_term, "_go_plot_top", show_cats[i], "_terms.pdf")), 
        plot = go_pl[[i]], 
        base_height = use_ht[i], base_width = 8)    
}
cAAA_go_pl <- go_pl
##########
## TATA vs DPE at stage 3
arch_term <- "TATAvsDPE"
# use_color <- RColorBrewer::brewer.pal(3, "Paired")
go_term_fs <- 12
show_cats <- c(5, 10)
use_ht <- c(6, 10)
## sample, clustID
clust_list <- list(c(2,1), c(2,8), c(3,2), c(3,3), c(3,4))


go_res <- lapply(clust_list, function(x){
                clusterProfiler::enrichGO(perSample_entrezList[[x[1]]][[x[2]]],
                    OrgDb = org.Dm.eg.db, ont = "all", pool = TRUE, 
                    keyType = "ENTREZID", 
                    pvalueCutoff = 0.05, qvalueCutoff = 0.1)
    })
names(go_res) <- paste0("C", 
                        unlist(lapply(clust_list, function(x) x[2])), 
                c("Y", "Y", "Z", "Z", "Z"))

compare_result <- clusterProfiler::merge_result(go_res)


go_pl <- vector("list", length(show_cats))
for(i in seq_along(show_cats)){
    p1 <- dotplot(compare_result, showCategory = show_cats[i],
                          title = paste0("Comparing ", arch_term, " architectures"),
                          font.size = go_term_fs)
    pl <- p1 + DOSE::theme_dose(font.size = go_term_fs) +
            ggplot2::scale_y_discrete(labels = scales::label_wrap(50)) +
            ggplot2::scale_color_gradient() + 
            ggplot2::theme(title = element_text(size = go_term_fs),
                           legend.text = element_text(size = go_term_fs),
                           legend.title = element_text(size = go_term_fs))
    go_pl[[i]] <- pl
    cowplot::save_plot(
        filename = file.path(result_dir_path, paste0(arch_term, "_go_plot_top", show_cats[i], "_terms.pdf")), 
        plot = go_pl[[i]], 
        base_height = use_ht[i], base_width = 8)    
}
TataVsDpe_go_pl <- go_pl

comb_pl <- cowplot::plot_grid(TataVsDpe_go_pl[[1]], tct_go_pl[[1]], ttant_go_pl[[1]], 
                    cAAA_go_pl[[1]], nrow = 2, labels = "AUTO", label_size = 14)

cowplot::save_plot(filename = file.path(result_dir_path, 
                                paste0("combined_top5_GO_term_enrichments_Drosophila_clusters.pdf")), 
                    plot = comb_pl, base_height = 10, base_width = 15)

comb_pl <- cowplot::plot_grid(TataVsDpe_go_pl[[2]], tct_go_pl[[2]], ttant_go_pl[[2]], 
                    cAAA_go_pl[[2]], nrow = 2, labels = "AUTO", label_size = 14)

cowplot::save_plot(filename = file.path(result_dir_path, 
                                paste0("combined_top10_GO_term_enrichments_Drosophila_clusters.pdf")), 
                    plot = comb_pl, base_height = 20, base_width = 15)


```



# Session Info

```{r sessionInfo, echo=FALSE}

sessionInfo()

```

